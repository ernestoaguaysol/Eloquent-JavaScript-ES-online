<!doctype html>
<head>
  <meta charset="utf-8">
  <title>Funciones :: Eloquent JavaScript</title>
  <link rel=stylesheet href="js/node_modules/codemirror/lib/codemirror.css">
  <script src="js/acorn_codemirror.js"></script>
  <link rel=stylesheet href="css/ejs.css">
  <script src="js/sandbox.js"></script>
  <script src="js/ejs.js"></script>
  <script>var chapNum = 3;</script>
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-53624335-3', 'auto');
  ga('send', 'pageview');

  </script>
</head>

<article>
<nav>
  <a href="02_program_structure.html" title="capítulo previo">◀</a>
  <a href="index.html" title="cover">◆</a>
  <a href="04_data.html" title="capítulo siguiente">▶</a>
</nav>

<h1><div class=chap_num>Capítulo 3</div>Funciones</h1>
<blockquote>
<p><a class=p_ident id="p_9tVXtW7iek" href="#p_9tVXtW7iek"></a>La gente piensa que las ciencias de la computación son el
arte de los genios pero la realidad es lo contrario, es sólo un
montón de gente haciendo cosas que se construyen sobre otras,
como una pared de piedras muy pequeñas.</p>
 <footer>Donald Knuth</footer>
</blockquote>
<p><a class=p_ident id="p_SpjssleoX5" href="#p_SpjssleoX5"></a>Has visto
valores función, como <code>alert</code>, y cómo llamarlos. Las funciones son el pan de
cada día en la programación en JavaScript. El concepto de de envolver
una porción del programa en un valor(variable) tiene muchos usos.
Es una herramienta para estructurar programas más grandes, para reducir
la repetición, para asociar nombres con subprogramas, y para separar
estos programas de los demás.</p>
<p><a class=p_ident id="p_5S1r7LDeWB" href="#p_5S1r7LDeWB"></a>La aplicación más obvia de las funciones es la de
definir un nuevo vocabulario. Crear nuevas palabras en la prosa regular en
lenguaje humano es usualmente un mal estilo. Pero en programación, es
indispensable.</p>
<p><a class=p_ident id="p_ixDBR5Xf6t" href="#p_ixDBR5Xf6t"></a>Un adulto promedio tiene unas 20,000 palabras en su
vocabulario. Pocos lenguajes de programación tienen 20,000 comandos
incorporados. Y el vocabulario que <em>está</em> disponible tiende a ser
definido de forma más precisa, así que es menos flexible
que en un lenguaje humano. En consecuencia, usualmente <em>tenemos</em>
que añadir algo de nuestro propio vocabulario para evitar repetirnos
demasiado.</p>
<h2><a class=h_ident id="h_j3HvZo/C/K" href="#h_j3HvZo/C/K"></a>Definiendo una función</h2>
<p><a class=p_ident id="p_5jo0JygqfX" href="#p_5jo0JygqfX"></a>Una definición de una función
es sólo una definición regular de una variable cuando ocurre que el
valor dado a la variable es una función. Por ejemplo, el siguiente código
define la variable <code>cuadrado</code> para referirse a la función que produce
el cuadrado de un número dado:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_8H/K+uBft0" href="#c_8H/K+uBft0"></a><span class="cm-keyword">var</span> <span class="cm-variable">cuadrado</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">x</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable-2">x</span> <span class="cm-operator">*</span> <span class="cm-variable-2">x</span>;
};

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">cuadrado</span>(<span class="cm-number">12</span>));
<span class="cm-comment">// → 144</span></pre>
<p><a class=p_ident id="p_zzTjhlbHB8" href="#p_zzTjhlbHB8"></a>Una función es
creada por una expresión que empieza con la palbra reservada <code>function</code>.
Las funciones tienen un conjunto de <em>parametros</em> (en este caso
sólo <code>x</code>) y un <em>cuerpo</em>, que contiene las sentencias que serán ejecutadas
cuando la función sea llamada. El cuerpo de la función tiene que estar
siempre encerrado en llaves, incluso cuando consista de una sola
instrucción (como en el ejemplo previo).</p>
<p><a class=p_ident id="p_l5IBusH/jt" href="#p_l5IBusH/jt"></a>Una función puede tener varios parámetros
o puede no tener ninguno. En el siguiente ejemplo <code>hazRuido</code> no tiene
parámetros, mientras que <code>potencia</code> tiene dos:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_f0YI3AJsrk" href="#c_f0YI3AJsrk"></a><span class="cm-keyword">var</span> <span class="cm-variable">hazRuido</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Pling!"</span>);
};

<span class="cm-variable">hazRuido</span>();
<span class="cm-comment">// → Pling!</span>

<span class="cm-keyword">var</span> <span class="cm-variable">potencia</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">base</span>, <span class="cm-def">exponente</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">resultado</span> <span class="cm-operator">=</span> <span class="cm-number">1</span>;
  <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">cuenta</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">cuenta</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">exponente</span>; <span class="cm-variable-2">cuenta</span><span class="cm-operator">++</span>)
    <span class="cm-variable-2">resultado</span> <span class="cm-operator">*=</span> <span class="cm-variable-2">base</span>;
  <span class="cm-keyword">return</span> <span class="cm-variable-2">resultado</span>;
};

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">potencia</span>(<span class="cm-number">2</span>, <span class="cm-number">10</span>));
<span class="cm-comment">// → 1024</span></pre>
<p><a class=p_ident id="p_2E/7l5vjIo" href="#p_2E/7l5vjIo"></a>Algunas
funciones producen un valor, como <code>potencia</code> y <code>cuadrado</code>, y algunas no,
como <code>hazRuido</code>, la cuál produce sólo un efecto secundario. Una sentencia
<code>return</code> determina el valor que una función regresa. Cuando el control
pasa a esta sentencia, inmediatamente salta fuera de la función actual
y pasa el valor retornado a la código que llamó la función. La palabra
reservada <code>return</code> sin una expresión después de ella hará que la función
devuelva <code>undefined</code>.</p>
<h2><a class=h_ident id="h_amIMEhTu+c" href="#h_amIMEhTu+c"></a>Parámetros y ámbitos</h2>
<p><a class=p_ident id="p_5frcwVH1y6" href="#p_5frcwVH1y6"></a>Los
parametros para una función se comportan como variables normales,
pero su valor inicial esta dado por <em>quien llama</em> a la función, no por
el código mismo de la función.</p>
<p><a class=p_ident id="p_c2ek95wYfT" href="#p_c2ek95wYfT"></a>Un propiedad
importante de las funciones es que las varibales creades dentro de ellas,
incluyendo sus parámetros, son <em>locales</em> para la función. Este significa,
por ejemplo, que la varibale <code>resultado</code> en el ejemplo <code>potencia</code> será
creada de nuvo cada vez que la función es llamada, y estas instancias
separadas no interfieren entre ellas.</p>
<p><a class=p_ident id="p_4sY+G0dpH/" href="#p_4sY+G0dpH/"></a>Esta
"localidad" de las variables aplica sólo a los parámetros y variables
declaradas con la palabra reservada <code>var</code> dentro del cuerpo de la función.
Las variables declaradas duera de cualquier función son llamadas <em>globales</em>,
porque son visibles a través de todo el programa. Es posible acceder a
estas variables desde dentro de una función, mientras no hayas declarado una
variable local con el mismo nombre.</p>
<p><a class=p_ident id="p_gt7VGvE5mW" href="#p_gt7VGvE5mW"></a>El siguiente código demuestra eso. Define y llama
dos funciones que asignan un valor a la variable <code>x</code>. La primera declara
la variable como local y de esta manera cambia únicamente la variable que
creó. La segunda no declara <code>x</code> localmente, así que la <code>x</code> dentro de ella
hace referencia a la <code>x</code> definida al principio del ejemplo.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_GH2xYj7azv" href="#c_GH2xYj7azv"></a><span class="cm-keyword">var</span> <span class="cm-variable">x</span> <span class="cm-operator">=</span> <span class="cm-string">"fuera"</span>;

<span class="cm-keyword">var</span> <span class="cm-variable">f1</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {
  <span class="cm-keyword">var</span> <span class="cm-def">x</span> <span class="cm-operator">=</span> <span class="cm-string">"dentro de f1"</span>;
};
<span class="cm-variable">f1</span>();
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">x</span>);
<span class="cm-comment">// → fuera</span>

<span class="cm-keyword">var</span> <span class="cm-variable">f2</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {
  <span class="cm-variable">x</span> <span class="cm-operator">=</span> <span class="cm-string">"dentro de f2"</span>;
};
<span class="cm-variable">f2</span>();
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">x</span>);
<span class="cm-comment">// → dentro de f2</span></pre>
<p><a class=p_ident id="p_QckB2bfRzS" href="#p_QckB2bfRzS"></a>Este comportamiento ayuda a prevenir interferencia accidental entre
las funciones. Si todas las variables fueran compartidas por el programa
entero, sería muy difícil asegurarse de que algún nombre no fue usado para
dos propósitos diferentes. Y si <em>reusaste</em> un nombre de variable, podrías
ver efectos extraños de código no relacionado causando problemas en el valor
de tu variable. Al tratar tus variables locales a la función, el lenguaje
hace posible leer y entender las funciones como un pequeños universos,
sin tener que preocuparse de todo el código a la vez.</p>
<h2 id="scoping"><a class=h_ident id="h_it+kYuuR73" href="#h_it+kYuuR73"></a>Ámbitos Anidados</h2>
<p><a class=p_ident id="p_OdtfoYXR2P" href="#p_OdtfoYXR2P"></a>JavaScript distingue nos solo entre variables <em>globales</em> y <em>locales</em>
Las funciones pueden ser creadas dentro de otras funciones,
produciendo distindos grados de                                   localidad.</p>
<p><a class=p_ident id="p_ET4L8vHq9N" href="#p_ET4L8vHq9N"></a>Por ejemplo, esta función sin sentido, tiene dos
funciones dentro de ella:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_Lk/0agSAFq" href="#c_Lk/0agSAFq"></a><span class="cm-keyword">var</span> <span class="cm-variable">paisaje</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {
  <span class="cm-keyword">var</span> <span class="cm-def">resultado</span> <span class="cm-operator">=</span> <span class="cm-string">""</span>;
  <span class="cm-keyword">var</span> <span class="cm-def">meseta</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">tamano</span>) {
    <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">cuenta</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">cuenta</span> <span class="cm-operator">&lt;</span> <span class="cm-variable">size</span>; <span class="cm-variable-2">cuenta</span><span class="cm-operator">++</span>)
      <span class="cm-variable-2">resultado</span> <span class="cm-operator">+=</span> <span class="cm-string">"_"</span>;
  };
  <span class="cm-keyword">var</span> <span class="cm-def">montana</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">tamano</span>) {
    <span class="cm-variable">result</span> <span class="cm-operator">+=</span> <span class="cm-string">"/"</span>;
    <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">cuenta</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">cuenta</span> <span class="cm-operator">&lt;</span> <span class="cm-variable">size</span>; <span class="cm-variable-2">cuenta</span><span class="cm-operator">++</span>)
      <span class="cm-variable-2">resultado</span> <span class="cm-operator">+=</span> <span class="cm-string">"'"</span>;
    <span class="cm-variable-2">resultado</span> <span class="cm-operator">+=</span> <span class="cm-string">"\\"</span>;
  };

  <span class="cm-variable-2">meseta</span>(<span class="cm-number">3</span>);
  <span class="cm-variable-2">montana</span>(<span class="cm-number">4</span>);
  <span class="cm-variable-2">meseta</span>(<span class="cm-number">6</span>);
  <span class="cm-variable-2">montana</span>(<span class="cm-number">1</span>);
  <span class="cm-variable-2">meseta</span>(<span class="cm-number">1</span>);
  <span class="cm-keyword">return</span> <span class="cm-variable-2">resultado</span>;
};

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">landscape</span>());
<span class="cm-comment">// → ___/''''\______/'\_</span></pre>
<p><a class=p_ident id="p_Npc1XBGqL1" href="#p_Npc1XBGqL1"></a>Las funciones <code>meseta</code> y <code>montana</code>
pueden "ver" la variable llamada <code>resultado</code>, debido a que están
dentro de la función que la define. Pero no pueden ver la variable
<code>cuenta</code> entre ellas, porque están definidas fuera del ámbito de la otra.
El entorno fuera de la función <code>paisaje</code> no puede acceder a ninguna de
las variables definidas dentro de <code>paisaje</code>.</p>
<p><a class=p_ident id="p_3dNxXtsvdX" href="#p_3dNxXtsvdX"></a>En pocas palabras, cada ámbito local también puede ver los ámbitos
locales que lo contienen. El conjunto de variables visible dentro de
la función es determinado por el lugar de la función en el texto del
programa. Todas las variables de los bloques que <em>envuelven</em> una
la definición de una función son visibles para ella, esto es, en todos
los cuerpos de las funciones que la envuelven y las correspondientes
al nivel superior(ámbito global). Este manera de resolver la visibilidad
de las variables es llamada <em>definición léxica de ámbito</em>(lexical scoping).</p>
<p><a class=p_ident id="p_FItQg1ObNB" href="#p_FItQg1ObNB"></a>Las personas que tienen experiencia con otros lenguajes
de programción podrían esperar que cualquier bloque entre llaves produzca
un nuevo entorno local. Pero en JavaScript, las funciones son lo único
que crea un nuevo ámbito. Pero puedes usar bloques independientes.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_v4MiIgTQg8" href="#c_v4MiIgTQg8"></a><span class="cm-keyword">var</span> <span class="cm-variable">algo</span> <span class="cm-operator">=</span> <span class="cm-number">1</span>;
{
  <span class="cm-keyword">var</span> <span class="cm-variable">algo</span> <span class="cm-operator">=</span> <span class="cm-number">2</span>;
  <span class="cm-comment">// Haz algo con la variable...</span>
}
<span class="cm-comment">// Fuera del bloque...</span></pre>
<p><a class=p_ident id="p_Whaz5dyKyX" href="#p_Whaz5dyKyX"></a>Pero la variable <code>algo</code> dentro del bloque se refiere a la misma variable
que la que está fuera del bloque. De hecho, aunque bloques como este
son permitidos, sólo son útiles para agrupar el cuerpo de las sentencias
<code>if</code> o de los bucles.</p>
<p><a class=p_ident id="p_S5AdAuXdUU" href="#p_S5AdAuXdUU"></a>Si esto te parece raro, no eres
el único. La próxima versión de  JavaScript introducirá una palabra
reservada <code>let</code>, que trabaja como <code>var</code> pero crea una variable que es
local para el <em>bloque</em> en el que está, no para la función.</p>
<h2><a class=h_ident id="h_3mNEhIfF61" href="#h_3mNEhIfF61"></a>Funciones como valores</h2>
<p><a class=p_ident id="p_SCewuuYiME" href="#p_SCewuuYiME"></a>Las variables de función normalmente actúan
como nombres para una parte específica del programa. Esa variables es
definida una vez y nunca cambiada. Esto hace fácil empezar a confundir
la función con su nombre.</p>
<p><a class=p_ident id="p_udPX9czPds" href="#p_udPX9czPds"></a>Pero son diferentes entre sí. Un valor función
puede hacer todo los que los otros valores pueden hacer; lo puedes usar
en expresiones arbitrarias, no sólo llamarlos. Es posible guardar la
función en un nuevo lugar, pasar como argumento a otra función, etc. De
manera parecida, la variable que contiene una función sigue siendo una variable
normal a la que se le puede asignar otro valor, como sigue:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_oAKHWurH8x" href="#c_oAKHWurH8x"></a><span class="cm-keyword">var</span> <span class="cm-variable">lanzarMisiles</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">valor</span>) {
  <span class="cm-variable">sistemaDeMisiles</span>.<span class="cm-property">lanzar</span>(<span class="cm-string">"ahora"</span>);
};
<span class="cm-keyword">if</span> (<span class="cm-variable">modoSeguro</span>)
  <span class="cm-variable">lanzarMisiles</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">valor</span>) {<span class="cm-comment">/* No hacer nada. */</span>};</pre>
<p><a class=p_ident id="p_Frk45di2F4" href="#p_Frk45di2F4"></a>En
<a href="05_higher_order.html#higher_order">Capítulo 5</a>, hablaremos de las
maravillosas cosas que puedes hacer al pasar valores función a otras funciones.</p>
<h2><a class=h_ident id="h_tL4D7etcu3" href="#h_tL4D7etcu3"></a>Notación de Declaración</h2>
<p><a class=p_ident id="p_3tXwhzuEAU" href="#p_3tXwhzuEAU"></a>Existe una
forma más corta de decir “<code>var square = function…</code>”. La palabra reservada
<code>function</code> puede ser usada al principio de una sentencia, como sigue:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_QLVSFJtGVV" href="#c_QLVSFJtGVV"></a><span class="cm-keyword">function</span> <span class="cm-variable">cuadrado</span>(<span class="cm-def">x</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable-2">x</span> <span class="cm-operator">*</span> <span class="cm-variable-2">x</span>;
}</pre>
<p><a class=p_ident id="p_I5VtBG0n0z" href="#p_I5VtBG0n0z"></a>Esta es una <em>declaración</em> de función.
La expresión define la variable <code>cuadrado</code> y la apunta a la función
dada. Hasta aquí todo bien. sin embargo, hay una pequeña sutileza con
esta forma de definición.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_BScavUBFBP" href="#c_BScavUBFBP"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"El futuro dice: "</span>, <span class="cm-variable">futuro</span>());

<span class="cm-keyword">function</span> <span class="cm-variable">future</span>() {
  <span class="cm-keyword">return</span> <span class="cm-string">"Seguimos sin tener carros voladores."</span>;
}</pre>
<p><a class=p_ident id="p_lIxAr6WEaB" href="#p_lIxAr6WEaB"></a>Este código funciona aunque la función está definida <em>debajo</em> del
código que la usa. Esto es debido a que las declaraciones de función
no toman parte en el flujo de control regular de arriba hacia abajo.
Son movidas conceptualmente a la parte superior de su ámbito y pueden
ser usadas por todo el código en ese ámbito. Esto es útil algunas veces
porque nos da la libertad de organizar el código de una manera parezca
significativa sin preocuparnos por definir todas las funciones antes de
su primer uso.</p>
<p><a class=p_ident id="p_0GxWZUSwt8" href="#p_0GxWZUSwt8"></a>¿Qué pasa cuando pones una declaración
de función dentro de un bloque condicional (<code>if</code>) o dentro de un bucle?
Bueno, mejor no lo hagas. Diferentes plataformas de JavaScript en
diferentes navegadores hacen diferentes cosas tradicionalmente en esa
situación, y el último estándar de hecho lo prohibe. Si quieres que
tus programas sean consistentes, usa las sentencia de declaración de función
en el bloque más externo de tu función o programa.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_x+G463250z" href="#c_x+G463250z"></a><span class="cm-keyword">function</span> <span class="cm-variable">ejemplo</span>() {
  <span class="cm-keyword">function</span> <span class="cm-def">a</span>() {} <span class="cm-comment">// Bien</span>
  <span class="cm-keyword">if</span> (<span class="cm-variable">alguna_condicion</span>) {
    <span class="cm-keyword">function</span> <span class="cm-def">b</span>() {} <span class="cm-comment">// ¡Peligro!</span>
  }
}</pre>
<h2 id="stack"><a class=h_ident id="h_nePB5S+L1Q" href="#h_nePB5S+L1Q"></a>La pila de llamadas</h2>
<p><a class=p_ident id="p_MIcX+dVOJH" href="#p_MIcX+dVOJH"></a> Será útil mirar más de
cerca la forma en que el control se mueve a través de las funciones.
Aquí hay un simple programa que hace unas cuantas llamadas a funciones.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_2mhgGbOeXv" href="#c_2mhgGbOeXv"></a><span class="cm-keyword">function</span> <span class="cm-variable">saluda</span>(<span class="cm-def">a_quien</span>) {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Hola "</span> <span class="cm-operator">+</span> <span class="cm-variable-2">a_quien</span>);
}
<span class="cm-variable">saluda</span>(<span class="cm-string">"Harry"</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Adiós"</span>);</pre>
<p><a class=p_ident id="p_X4F0pqfkKz" href="#p_X4F0pqfkKz"></a>(((console.log))Una ejecución
de este programa va más o menos así: la llamada a <code>saluda</code> causa que el control
pase al inicio de esa función (línea 2). Esta llama a <code>control.log</code> (una función
incluída en los navegadores), que toma el control, hace su trabajo, y devuelve
el control a la línea 2. Después, se alcanza el dinal de la función <code>saluda</code>, así
que se regresa al lugar en dónde se llamó, en la línea 4. La línea siguiente llama
a <code>console.log</code> otra vez.</p>
<p><a class=p_ident id="p_U3XWu6xDX+" href="#p_U3XWu6xDX+"></a>Podemos mostrar el flujo de control esquemáticamente así:</p>
<pre>raíz
   saluda
        console.log
   saluda
raíz
   console.log
raíz</pre>
<p><a class=p_ident id="p_JBwQYCOD0U" href="#p_JBwQYCOD0U"></a>Debido a que una función tiene que
saltar de regreso al lugar en que fue llamada cuando termine, la computadora
debe recordar el contexto en el que fue llamada. En un caso, <code>console.log</code> tiene
que regresar a la función <code>saluda</code>. En el otro caso salta al final del programa.</p>
<p><a class=p_ident id="p_q+Dy7vNOH+" href="#p_q+Dy7vNOH+"></a>El lugar en el que la computadora guarda este context es la <em>pila de llamadas</em>.
Cada vez que una función es llamada, el contexto actual es puesto en la parte superior
de esta pila. Cuando la función retorne, remueve el contexto superior de la "pila" y
lo usa para continuar la ejecución.</p>
<p><a class=p_ident id="p_K5Ire0rChj" href="#p_K5Ire0rChj"></a>Guardar esta pila requiere
espacio en la memoria de la coputadora. Cuando la pila se hace demasiado grande
la computadora mostrará un error parecido a "out of stack space" (sin espacio en la
en la pila) o "too much recursion" (demasiada recursión). El siguiente código lo ilustra
al preguntarle algo realmente difícil a la computadora, lo que causa un ir y venir
infinito entre funciones. Más bien, <em>sería</em> infinito, si la computadora
tuviera una pila infinita. Como son las cosas, nos quedaremos sin espacio,
o "volaremos la pila".</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_AhBAx37CuW" href="#c_AhBAx37CuW"></a><span class="cm-keyword">function</span> <span class="cm-variable">gallina</span>() {
  <span class="cm-keyword">return</span> <span class="cm-variable">huevo</span>();
}
<span class="cm-keyword">function</span> <span class="cm-variable">huevo</span>() {
  <span class="cm-keyword">return</span> <span class="cm-variable">gallina</span>();
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">gallina</span>() <span class="cm-operator">+</span> <span class="cm-string">" fue primero"</span>);
<span class="cm-comment">// → ??</span></pre>
<h2><a class=h_ident id="h_jNCGCF3rFb" href="#h_jNCGCF3rFb"></a>Argumentos Opcionales</h2>
<p><a class=p_ident id="p_H9TL95isqo" href="#p_H9TL95isqo"></a>El siguiente código es permitido y se ejecuta sin
ningún problema:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_U6A9mZYPyZ" href="#c_U6A9mZYPyZ"></a><span class="cm-variable">alert</span>(<span class="cm-string">"Hola"</span>, <span class="cm-string">"Buenas Noches"</span>, <span class="cm-string">"¿Cómo estás?"</span>);</pre>
<p><a class=p_ident id="p_h45iKuBld5" href="#p_h45iKuBld5"></a>La función <code>alert</code> oficialmente acepta sólo un argumento.
Aún así, cuando la llamas como aquí, no se queja. Simplemente ignora los otros
argumentos y te muestra "Hola".</p>
<p><a class=p_ident id="p_CFCRGRqAfJ" href="#p_CFCRGRqAfJ"></a>JavaScript es extremadamente abierta de mente
acerca del número de argumentos que le pasas a una función. Sí le pasas demasiados,
loa argumentos extra son ignorados. Si le pasas muy pocos, los parámetros quie faltan
simplemente son asignados a <code>undefined</code>.</p>
<p><a class=p_ident id="p_byAKowZLIp" href="#p_byAKowZLIp"></a>El lado malo de esto es que es posbible/probable, casi seguro que le pasarás
accidentalmente un número incorrecto de argumentos a las funciones y nadie te
avisará.</p>
<p id="potencia"><a class=p_ident id="p_MLpfFTxf6C" href="#p_MLpfFTxf6C"></a> El lado bueno de este
comportamiento es que puede ser usado para tener una función que
tome parámetros "opcionales". Por ejemplo, la siguiente versión de
<code>potencia</code> puede ser llamada con dos argumentos o uno solo, caso en el que
el exponente se asume como dos, y la función se comporta como <code>cuadrado</code>.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_ZanpM9q23d" href="#c_ZanpM9q23d"></a><span class="cm-keyword">function</span> <span class="cm-variable">potencia</span>(<span class="cm-def">base</span>, <span class="cm-def">exponente</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">exponente</span> <span class="cm-operator">==</span> <span class="cm-atom">undefined</span>)
    <span class="cm-variable-2">exponente</span> <span class="cm-operator">=</span> <span class="cm-number">2</span>;
  <span class="cm-keyword">var</span> <span class="cm-def">resultado</span> <span class="cm-operator">=</span> <span class="cm-number">1</span>;
  <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">cuenta</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">cuenta</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">exponente</span>; <span class="cm-variable-2">cuenta</span><span class="cm-operator">++</span>)
    <span class="cm-variable-2">resultado</span> <span class="cm-operator">*=</span> <span class="cm-variable-2">base</span>;
  <span class="cm-keyword">return</span> <span class="cm-variable-2">resultado</span>;
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">potencia</span>(<span class="cm-number">4</span>));
<span class="cm-comment">// → 16</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">potencia</span>(<span class="cm-number">4</span>, <span class="cm-number">3</span>));
<span class="cm-comment">// → 64</span></pre>
<p><a class=p_ident id="p_qDx8VfKunp" href="#p_qDx8VfKunp"></a>En el <a href="04_data.html#arguments_object">próximo
capítulo</a>, veremos una forma en la que el cuerpo de una función puede
obetener la lista exacta de argumentos que se le pasaron. Esto es útil
porque permite a una función aceptar un número indeterminado de argumentos.
Por ejemplo, <code>console.log</code> hace uso de esto: imprime todos los valores que
se le pasaron.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_rwDFIqBrDl" href="#c_rwDFIqBrDl"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"R"</span>, <span class="cm-number">2</span>, <span class="cm-string">"D"</span>, <span class="cm-number">2</span>);
<span class="cm-comment">// → R 2 D 2</span></pre>
<h2><a class=h_ident id="h_hOd+yVxaku" href="#h_hOd+yVxaku"></a>Closure</h2>
<p><a class=p_ident id="p_eDid6K5Fi2" href="#p_eDid6K5Fi2"></a> La habilidad de tratar Funciones
como valores, combinada con el hecho de que las varibles locales son
"re-creadas" cada vez que una función es llamada, saca a la luz
una pregunta interesante. ¿Qué pasa con las variables locales
cuando la función que las creó ya no está activa?</p>
<p><a class=p_ident id="p_Kb5dHADISx" href="#p_Kb5dHADISx"></a>El siguiente código muestra un ejemplo de esto. Define una funnción,
<code>envuelveValor</code>, que crea una variable local. Después devuelve una
función que accede y devuelve esta variable local.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_F1jDyB51/z" href="#c_F1jDyB51/z"></a><span class="cm-keyword">function</span> <span class="cm-variable">envuelveValor</span>(<span class="cm-def">n</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">variableLocal</span> <span class="cm-operator">=</span> <span class="cm-variable-2">n</span>;
  <span class="cm-keyword">return</span> <span class="cm-keyword">function</span>() { <span class="cm-keyword">return</span> <span class="cm-variable-2">variableLocal</span>; };
}

<span class="cm-keyword">var</span> <span class="cm-variable">envoltura1</span> <span class="cm-operator">=</span> <span class="cm-variable">envuelveValor</span>(<span class="cm-number">1</span>);
<span class="cm-keyword">var</span> <span class="cm-variable">envoltura2</span> <span class="cm-operator">=</span> <span class="cm-variable">envuelveValor</span>(<span class="cm-number">2</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">envoltura11</span>());
<span class="cm-comment">// → 1</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">envoltura2</span>());
<span class="cm-comment">// → 2</span></pre>
<p><a class=p_ident id="p_7RHFNfs+6E" href="#p_7RHFNfs+6E"></a>Esto está permitido y funciona como esperarías; la variable todavía puede
leerse. De hecho, múltiples instancias de las variables pueden existir
al mismo tiempo, lo que es otra buena ilustración del concepto de que las
variables locales son re-creadas realmente para cada llamada; diferentes
llamadas no pueden afectar otras variables locales.</p>
<p><a class=p_ident id="p_MeN/dq9I07" href="#p_MeN/dq9I07"></a>Esta característica -ser capaces de hacer referencia a una instancia
local de varables en un función que las encierra- se llama <em><em>closure</em></em>.
Una función que "encapsula" algunas variables locales es llamada <em>una</em>
closure. Este comportamiento no sólo te libera de preocuparte de los
tiempos de vida de las variables, además permite algunos usos creativos
de las funciones.</p>
<p><a class=p_ident id="p_CeJ9uPCSdy" href="#p_CeJ9uPCSdy"></a> Con un pequeño cambio, podemos podemos hacer
del ejemplo anterior funciones que multiplicquen por un número arbitrario.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_p48VPEMIYL" href="#c_p48VPEMIYL"></a><span class="cm-keyword">function</span> <span class="cm-variable">multiplicador</span>(<span class="cm-def">factor</span>) {
  <span class="cm-keyword">return</span> <span class="cm-keyword">function</span>(<span class="cm-def">numero</span>) {
    <span class="cm-keyword">return</span> <span class="cm-variable-2">numero</span> <span class="cm-operator">*</span> <span class="cm-variable-2">factor</span>;
  };
}

<span class="cm-keyword">var</span> <span class="cm-variable">doble</span> <span class="cm-operator">=</span> <span class="cm-variable">multiplicador</span>(<span class="cm-number">2</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">doble</span>(<span class="cm-number">5</span>));
<span class="cm-comment">// → 10</span></pre>
<p><a class=p_ident id="p_tsNc0owPeX" href="#p_tsNc0owPeX"></a> La variable explícita <code>variableLocal</code> de la
función <code>envuelveValor</code> en el ejemplo previo no es necesaria porque un
parámetro en sí mismo es una variable local.</p>
<p><a class=p_ident id="p_63fqkh11UW" href="#p_63fqkh11UW"></a>Concebir los parámetros de esta forma
requiere algo de práctica. Un buen modelo mental es pensar en la
palabra clave <code>function</code> como si "congelara" el código que está dentro de
ella en un paquete(el valor función). Así, cuando leas <code>return function(...){...}</code>,
piensa en que esto regresa un acceso a un conjunto de cálculos, congelados
para uso posterior.</p>
<p><a class=p_ident id="p_OQuM9H6apZ" href="#p_OQuM9H6apZ"></a>En el ejemplo, <code>multiplicador</code> regresa un pedazo congelado de código que
se guarda en la variable <code>doble</code>. La última línea entonces llama el valor
guardado en esta variable, haciendo que el código congelado (<code>return numero * factor;</code>)
se active. Este todavía tiene acceso a la variable <code>factor</code> de la llamada a
<code>multiplicador</code> que lo creó, y además obtiene acceso al argumento que se pasa
cuando se activa el código, 5, a través de su parámetro <code>numero</code>.</p>
<h2><a class=h_ident id="h_TDpZBcOUPE" href="#h_TDpZBcOUPE"></a>Recursión</h2>
<p><a class=p_ident id="p_LLUe70k/Vn" href="#p_LLUe70k/Vn"></a>Es perfectamente correcto que
una función se llame a sí misma, mientras tenga cuidado de no desbordar la pila.
Una función que se llama a sí misma se llama <em>recursiva</em>. La recursión permite
que algunas funciones se escriban con un estilo diferente. Tomemos por ejemplo,
esta implementación alternativa de <code>potencia</code>:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_MAKKXW2qQR" href="#c_MAKKXW2qQR"></a><span class="cm-keyword">function</span> <span class="cm-variable">potencia</span>(<span class="cm-def">base</span>, <span class="cm-def">exponente</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">exponente</span> <span class="cm-operator">==</span> <span class="cm-number">0</span>)
    <span class="cm-keyword">return</span> <span class="cm-number">1</span>;
  <span class="cm-keyword">else</span>
    <span class="cm-keyword">return</span> <span class="cm-variable-2">base</span> <span class="cm-operator">*</span> <span class="cm-variable">potencia</span>(<span class="cm-variable-2">base</span>, <span class="cm-variable-2">exponente</span> <span class="cm-operator">-</span> <span class="cm-number">1</span>);
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">potencia</span>(<span class="cm-number">2</span>, <span class="cm-number">3</span>));
<span class="cm-comment">// → 8</span></pre>
<p><a class=p_ident id="p_dJWO6MGGCR" href="#p_dJWO6MGGCR"></a> Esto es más cercano
al modo en que los matemáticos definen la potenciación y describe
el concepto de un modo más elegante que la variante que lo hace con bucles.
La función se llama a sí misma varias veces con diferentes argumentos
para conseguir la multiplicación repetida.</p>
<p><a class=p_ident id="p_ZTlTujVn8E" href="#p_ZTlTujVn8E"></a>Pero esta implementación tiene
un problema importante: en implementaciones típicas de JavaScript, es
cerca de 10 veces más lenta que la versión con bucles. Correr a través
de un siple bucle es más barato que llamar a una función muchas veces.</p>
<p><a class=p_ident id="p_1D1aVQEebE" href="#p_1D1aVQEebE"></a>El dilema de velocidad contra elegancia es interesante.
Puedes verlo como un continuum entre amigabilidad-humano y amigabilidad-máquina.
Casi cualquier programa puede hacerse más rápido haciéndolo más grande
y convolucionado. El programador debe de decidir el balance apropiado.</p>
<p><a class=p_ident id="p_pAPmgTlzgU" href="#p_pAPmgTlzgU"></a>En el caso de la función <a href="03_functions.html#potencia">anterior</a> <code>potencia</code>
la poco elegante versión(iterativa) es aún bastante simple y fácil de leer.
No tiene mucho sentido reemplazarla con la versión recursiva. A menudo,
sin embargo, un programa tiene conceptos tan complejos que sacrificar
un poco de eficiencia para hacer el programa más claro se vuelve una
opción atractiva.</p>
<p><a class=p_ident id="p_Z84ZhvaURK" href="#p_Z84ZhvaURK"></a> La regla básica, que ha sido repetida por muchos programadores
y con la cuál concuerdo de todo corazón, es no preocuparse por
la eficiencia hasta que estés seguro que el programa es demasiado lento.
Si lo es, busca las partes que están abarcando la mayoría del tiempo
y empieza a cambiar elegancia por eficiencia en esas partes.</p>
<p><a class=p_ident id="p_Js9hi3NYJu" href="#p_Js9hi3NYJu"></a>Por supuesto, esta regla no significa que debas ignorar el rendimiento
completamente. En muchos casos, como en la función <code>potencia</code>,
no se gana demasiada simplicidad de la solución "elegante". Y algunas
veces un programador experimentado puede inmediatamente que un
soulución simple nunca va a ser lo suficientemente rápida.</p>
<p><a class=p_ident id="p_+UI2VoiIJm" href="#p_+UI2VoiIJm"></a>La razón por la que estoy hablando tanto
de esto es que muchos programadores novatos se enfocan fanáticamente
en la eficiencia, incluso en los detalles más pequeños. El resultado
son programas más grandes, más complicados y a menudo menos correctos,
que toman más tiempo en escribirse que sus equivalentes más sencillos
y que generalmente corren solo un poco más rápido.</p>
<p><a class=p_ident id="p_NVKCM4shea" href="#p_NVKCM4shea"></a>Pero la recursión no es siempre sólo
una alternativa menos eficiente a los bucles. Alguos problemas son
mucho más fáciles de resolver con recursión que con bucles. La mayoría
de estos son problemas que requieren explorar o procesar varias "ramas",
cada una de las cuáles se puede ramificar otra vez.</p>
<p id="rompecabezas_recursivo"><a class=p_ident id="p_1cm1ulHv3t" href="#p_1cm1ulHv3t"></a>Considera el siguente
rompecabezas: empezando por el número 1 y añadiendo repetidamente 5 o
multiplicándolo por 3, un número infinito de nuevos números puede ser producido.
¿Cómo escribirías una función que, dado un número, trate de encontrar una
secuencia de sumas y multipliclaciones que producen ese número?
Por ejemplo, el número 13 puede ser producido al multiplicar por 3 primero
y después sumar 5 dos veces, mientras que el número 15 no puede ser producido.</p>
<p><a class=p_ident id="p_6eI6hyPXeT" href="#p_6eI6hyPXeT"></a>Aquí hay una solución recursiva:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_Eg4adhDpWx" href="#c_Eg4adhDpWx"></a><span class="cm-keyword">function</span> <span class="cm-variable">encontrarSolucion</span>(<span class="cm-def">objetivo</span>) {
  <span class="cm-keyword">function</span> <span class="cm-def">encontrar</span>(<span class="cm-def">inicio</span>, <span class="cm-def">historia</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">inicio</span> <span class="cm-operator">==</span> <span class="cm-variable-2">objetivo</span>)
      <span class="cm-keyword">return</span> <span class="cm-variable-2">historia</span>;
    <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">inicio</span> <span class="cm-operator">></span> <span class="cm-variable-2">objetivo</span>)
      <span class="cm-keyword">return</span> <span class="cm-atom">null</span>;
    <span class="cm-keyword">else</span>
      <span class="cm-keyword">return</span> <span class="cm-variable-2">encontrar</span>(<span class="cm-variable-2">inicio</span> <span class="cm-operator">+</span> <span class="cm-number">5</span>, <span class="cm-string">"("</span> <span class="cm-operator">+</span> <span class="cm-variable-2">historia</span> <span class="cm-operator">+</span> <span class="cm-string">" + 5)"</span>) <span class="cm-operator">||</span>
             <span class="cm-variable-2">encontrar</span>(<span class="cm-variable-2">inicio</span> <span class="cm-operator">*</span> <span class="cm-number">3</span>, <span class="cm-string">"("</span> <span class="cm-operator">+</span> <span class="cm-variable-2">historia</span> <span class="cm-operator">+</span> <span class="cm-string">" * 3)"</span>);
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">encontrar</span>(<span class="cm-number">1</span>, <span class="cm-string">"1"</span>);
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">encontrarSolucion</span>(<span class="cm-number">24</span>));
<span class="cm-comment">// → (((1 * 3) + 5) * 3)</span></pre>
<p><a class=p_ident id="p_1Lme2+0OFW" href="#p_1Lme2+0OFW"></a>Nota que este programa no encuentra necesariamente la ruta
<em>más corta</em> de operaciones. Se satisface cuando cuentre cualquier sequencia.</p>
<p><a class=p_ident id="p_yRASkciCuK" href="#p_yRASkciCuK"></a>No necesariamente espero que veas como este trabaja esto inmediatamente. Pero
trabajemos en eso, porque es un gran ejercicio en el pensamiento recursivo.</p>
<p><a class=p_ident id="p_TdwUEI2F58" href="#p_TdwUEI2F58"></a>The inner function <code>find</code> does the actual recursing. It takes two
arguments—the current number and a string that records how we
reached this number—and returns either a string that shows how to get
to the target or <code>null</code>.</p>
<p><a class=p_ident id="p_QSzesXs0Kg" href="#p_QSzesXs0Kg"></a>To do this, the
function performs one of three actions. If the current number is the
target number, the current history is a way to reach that target, so
it is simply returned. If the current number is greater than the
target, there&#8217;s no sense in further exploring this history since both
adding and multiplying will only make the number bigger. And finally,
if we&#8217;re still below the target, the function tries both possible
paths that start from the current number, by calling itself twice,
once for each of the allowed next steps. If the first call returns
something that is not <code>null</code>, it is returned. Otherwise, the second
call is returned—regardless of whether it produces a string or <code>null</code>.</p>
<p><a class=p_ident id="p_QvX/6dUvST" href="#p_QvX/6dUvST"></a>To better understand how this function produces the
effect we&#8217;re looking for, let&#8217;s look at all the calls to <code>find</code> that
are made when searching for a solution for the number 13.</p>
<pre>find(1, "1")
  find(6, "(1 + 5)")
    find(11, "((1 + 5) + 5)")
      find(16, "(((1 + 5) + 5) + 5)")
        too big
      find(33, "(((1 + 5) + 5) * 3)")
        too big
    find(18, "((1 + 5) * 3)")
      too big
  find(3, "(1 * 3)")
    find(8, "((1 * 3) + 5)")
      find(13, "(((1 * 3) + 5) + 5)")
        found!</pre>
<p><a class=p_ident id="p_acU+LwVT0i" href="#p_acU+LwVT0i"></a>The indentation suggests the depth of the call stack. The first time
<code>find</code> is called it calls itself twice to explore the solutions that start with
<code>(1 + 5)</code> and <code>(1 * 3)</code>. The first call tries to find a solution that
starts with <code>(1 + 5)</code> and, using recursion, explores <em>every</em> solution
that yields a number less than or equal to the target number. Since
it doesn&#8217;t find a solution that hits the target, it returns <code>null</code>
back to the first call. There the <code>||</code> operator causes the call that
explores <code>(1 * 3)</code> to happen. This search has more luck because its
first recursive call, through yet <em>another</em> recursive call, hits upon
the target number, 13. This innermost recursive call returns a string,
and each of the <code>||</code> operators in the intermediate calls pass that
string along, ultimately returning our solution.</p>
<h2><a class=h_ident id="h_eVDWIAuyBK" href="#h_eVDWIAuyBK"></a>Growing functions</h2>
<p><a class=p_ident id="p_FDJnaYNBaa" href="#p_FDJnaYNBaa"></a>There are two more or less natural ways for
functions to be introduced into programs.</p>
<p><a class=p_ident id="p_zNh7WEzSLI" href="#p_zNh7WEzSLI"></a>The first is that you find yourself writing very
similar code multiple times. We want to avoid doing that since having
more code means more space for mistakes to hide and more material to
read for people trying to understand the program. So we take the
repeated functionality, find a good name for it, and put it into a
function.</p>
<p><a class=p_ident id="p_HJxU0H/STP" href="#p_HJxU0H/STP"></a>The second way is that you find you need some functionality that you
haven&#8217;t written yet and that sounds like it deserves its own function.
You&#8217;ll start by naming the function, and you&#8217;ll then write its body.
You might even start writing code that uses the function before you
actually define the function itself.</p>
<p><a class=p_ident id="p_7YCpyNM9KP" href="#p_7YCpyNM9KP"></a>How difficult it is to find
a good name for a function is a good indication of how clear a concept
it is that you&#8217;re trying to wrap. Let&#8217;s go through an example.</p>
<p><a class=p_ident id="p_NB82EwGY1X" href="#p_NB82EwGY1X"></a>We want to write a program that prints two numbers,
the numbers of cows and chickens on a farm, with the words <code>Cows</code> and
<code>Chickens</code> after them, and zeros padded before both numbers so that
they are always three digits long.</p>
<pre>007 Cows
011 Chickens</pre>
<p><a class=p_ident id="p_Vjv/1yrqWB" href="#p_Vjv/1yrqWB"></a>That clearly asks for a function of two arguments. Let&#8217;s get coding.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_3FZcO2H/2C" href="#c_3FZcO2H/2C"></a><span class="cm-keyword">function</span> <span class="cm-variable">printFarmInventory</span>(<span class="cm-def">cows</span>, <span class="cm-def">chickens</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">cowString</span> <span class="cm-operator">=</span> <span class="cm-variable">String</span>(<span class="cm-variable-2">cows</span>);
  <span class="cm-keyword">while</span> (<span class="cm-variable-2">cowString</span>.<span class="cm-property">length</span> <span class="cm-operator">&lt;</span> <span class="cm-number">3</span>)
    <span class="cm-variable-2">cowString</span> <span class="cm-operator">=</span> <span class="cm-string">"0"</span> <span class="cm-operator">+</span> <span class="cm-variable-2">cowString</span>;
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable-2">cowString</span> <span class="cm-operator">+</span> <span class="cm-string">" Cows"</span>);
  <span class="cm-keyword">var</span> <span class="cm-def">chickenString</span> <span class="cm-operator">=</span> <span class="cm-variable">String</span>(<span class="cm-variable-2">chickens</span>);
  <span class="cm-keyword">while</span> (<span class="cm-variable-2">chickenString</span>.<span class="cm-property">length</span> <span class="cm-operator">&lt;</span> <span class="cm-number">3</span>)
    <span class="cm-variable-2">chickenString</span> <span class="cm-operator">=</span> <span class="cm-string">"0"</span> <span class="cm-operator">+</span> <span class="cm-variable-2">chickenString</span>;
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable-2">chickenString</span> <span class="cm-operator">+</span> <span class="cm-string">" Chickens"</span>);
}
<span class="cm-variable">printFarmInventory</span>(<span class="cm-number">7</span>, <span class="cm-number">11</span>);</pre>
<p><a class=p_ident id="p_iRp07gdia7" href="#p_iRp07gdia7"></a>Adding <code>.length</code>
after a string value will give us the length of that string. Thus, the
<code>while</code> loops keep adding zeros in front of the number strings until
they are at least three characters long.</p>
<p><a class=p_ident id="p_hlBZoLuLCG" href="#p_hlBZoLuLCG"></a>Mission accomplished! But just as we are about to send the farmer the
code (along with a hefty invoice, of course), he calls and tells us
he&#8217;s also started keeping pigs, and couldn&#8217;t we please extend the
software to also print pigs?</p>
<p><a class=p_ident id="p_h9O1PaViIa" href="#p_h9O1PaViIa"></a>We sure can. But just as we&#8217;re in the
process of copying and pasting those four lines one more time, we stop
and reconsider. There has to be a better way. Here&#8217;s a first attempt:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_MyKuhBUtsp" href="#c_MyKuhBUtsp"></a><span class="cm-keyword">function</span> <span class="cm-variable">printZeroPaddedWithLabel</span>(<span class="cm-def">number</span>, <span class="cm-def">label</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">numberString</span> <span class="cm-operator">=</span> <span class="cm-variable">String</span>(<span class="cm-variable-2">number</span>);
  <span class="cm-keyword">while</span> (<span class="cm-variable-2">numberString</span>.<span class="cm-property">length</span> <span class="cm-operator">&lt;</span> <span class="cm-number">3</span>)
    <span class="cm-variable-2">numberString</span> <span class="cm-operator">=</span> <span class="cm-string">"0"</span> <span class="cm-operator">+</span> <span class="cm-variable-2">numberString</span>;
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable-2">numberString</span> <span class="cm-operator">+</span> <span class="cm-string">" "</span> <span class="cm-operator">+</span> <span class="cm-variable-2">label</span>);
}

<span class="cm-keyword">function</span> <span class="cm-variable">printFarmInventory</span>(<span class="cm-def">cows</span>, <span class="cm-def">chickens</span>, <span class="cm-def">pigs</span>) {
  <span class="cm-variable">printZeroPaddedWithLabel</span>(<span class="cm-variable-2">cows</span>, <span class="cm-string">"Cows"</span>);
  <span class="cm-variable">printZeroPaddedWithLabel</span>(<span class="cm-variable-2">chickens</span>, <span class="cm-string">"Chickens"</span>);
  <span class="cm-variable">printZeroPaddedWithLabel</span>(<span class="cm-variable-2">pigs</span>, <span class="cm-string">"Pigs"</span>);
}

<span class="cm-variable">printFarmInventory</span>(<span class="cm-number">7</span>, <span class="cm-number">11</span>, <span class="cm-number">3</span>);</pre>
<p><a class=p_ident id="p_6/4BxnwWvK" href="#p_6/4BxnwWvK"></a>It works! But that name,
<code>printZeroPaddedWithLabel</code>, is a little awkward. It conflates three
things—printing, zero-padding, and adding a label—into a single
function.</p>
<p><a class=p_ident id="p_/zEyox400N" href="#p_/zEyox400N"></a>Instead of lifting out the repeated part of our
program wholesale, let&#8217;s try to pick out a single <em>concept</em>.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_BF/ji546Xh" href="#c_BF/ji546Xh"></a><span class="cm-keyword">function</span> <span class="cm-variable">zeroPad</span>(<span class="cm-def">number</span>, <span class="cm-def">width</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">string</span> <span class="cm-operator">=</span> <span class="cm-variable">String</span>(<span class="cm-variable-2">number</span>);
  <span class="cm-keyword">while</span> (<span class="cm-variable-2">string</span>.<span class="cm-property">length</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">width</span>)
    <span class="cm-variable-2">string</span> <span class="cm-operator">=</span> <span class="cm-string">"0"</span> <span class="cm-operator">+</span> <span class="cm-variable-2">string</span>;
  <span class="cm-keyword">return</span> <span class="cm-variable-2">string</span>;
}

<span class="cm-keyword">function</span> <span class="cm-variable">printFarmInventory</span>(<span class="cm-def">cows</span>, <span class="cm-def">chickens</span>, <span class="cm-def">pigs</span>) {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">zeroPad</span>(<span class="cm-variable-2">cows</span>, <span class="cm-number">3</span>) <span class="cm-operator">+</span> <span class="cm-string">" Cows"</span>);
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">zeroPad</span>(<span class="cm-variable-2">chickens</span>, <span class="cm-number">3</span>) <span class="cm-operator">+</span> <span class="cm-string">" Chickens"</span>);
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">zeroPad</span>(<span class="cm-variable-2">pigs</span>, <span class="cm-number">3</span>) <span class="cm-operator">+</span> <span class="cm-string">" Pigs"</span>);
}

<span class="cm-variable">printFarmInventory</span>(<span class="cm-number">7</span>, <span class="cm-number">16</span>, <span class="cm-number">3</span>);</pre>
<p><a class=p_ident id="p_GAKg8ZzVbj" href="#p_GAKg8ZzVbj"></a>A function with a nice, obvious
name like <code>zeroPad</code> makes it easier for someone who reads the code to
figure out what it does. And it is useful in more situations than just
this specific program. For example, you could use it to help print
nicely aligned tables of numbers.</p>
<p><a class=p_ident id="p_JtW9SrsIA6" href="#p_JtW9SrsIA6"></a>How smart and versatile should our function be?
We could write anything from a terribly simple function that simply
pads a number so that it&#8217;s three characters wide to a complicated
generalized number-formatting system that handles fractional numbers,
negative numbers, alignment of dots, padding with different
characters, and so on.</p>
<p><a class=p_ident id="p_EWzoSpSKwh" href="#p_EWzoSpSKwh"></a>A useful principle is not to add cleverness unless you are absolutely
sure you&#8217;re going to need it. It can be tempting to write general
“frameworks” for every little bit of functionality you come
across. Resist that urge. You won&#8217;t get any real work done, and you&#8217;ll
end up writing a lot of code that no one will ever use.</p>
<h2 id="pure"><a class=h_ident id="h_EdyBGBF6y/" href="#h_EdyBGBF6y/"></a>Functions and side effects</h2>
<p><a class=p_ident id="p_Yv2DEaMWee" href="#p_Yv2DEaMWee"></a>Functions can
be roughly divided into those that are called for their side effects
and those that are called for their return value. (Though it is
definitely also possible to have both side effects and return a
value.)</p>
<p><a class=p_ident id="p_NoFe+XFM0N" href="#p_NoFe+XFM0N"></a>The first helper function in the farm example,
<code>printZeroPaddedWithLabel</code>, is called for its side effect: it prints a
line. The second version, <code>zeroPad</code>, is called for its return value.
It is no coincidence that the second is useful in more situations than
the first. Functions that create values are easier to combine in new
ways than functions that directly perform side effects.</p>
<p><a class=p_ident id="p_jtr5vcWSkM" href="#p_jtr5vcWSkM"></a>A <em>pure</em> function is a specific kind of
value-producing function that not only has no side effects but also
doesn&#8217;t rely on side effects from other code—for example, it doesn&#8217;t
read global variables that are occasionally changed by other code. A
pure function has the pleasant property that, when called with the
same arguments, it always produces the same value (and doesn&#8217;t do
anything else). This makes it easy to reason about. A call to such a
function can be mentally substituted by its result, without changing
the meaning of the code. When you are not sure that a pure function is
working correctly, you can test it by simply calling it, and know that
if it works in that context, it will work in any context. Nonpure
functions might return different values based on all kinds of factors
and have side effects that might be hard to test and think about.</p>
<p><a class=p_ident id="p_BQs40ApxUr" href="#p_BQs40ApxUr"></a>Still, there&#8217;s no need to feel bad
when writing functions that are not pure or to wage a holy war to
purge them from your code. Side effects are often useful. There&#8217;d be
no way to write a pure version of <code>console.log</code>, for example, and
<code>console.log</code> is certainly useful. Some operations are also easier to
express in an efficient way when we use side effects, so computing
speed can be a reason to avoid purity.</p>
<h2><a class=h_ident id="h_ErccPg/l98" href="#h_ErccPg/l98"></a>Summary</h2>
<p><a class=p_ident id="p_mvDkl8+Eqg" href="#p_mvDkl8+Eqg"></a>This chapter taught you how to write your own functions. The
<code>function</code> keyword, when used as an expression, can create a function
value. When used as a statement, it can be used to declare a variable
and give it a function as its value.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_YPhf/PZ0FA" href="#c_YPhf/PZ0FA"></a><span class="cm-comment">// Create a function value f</span>
<span class="cm-keyword">var</span> <span class="cm-variable">f</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">a</span>) {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable-2">a</span> <span class="cm-operator">+</span> <span class="cm-number">2</span>);
};

<span class="cm-comment">// Declare g to be a function</span>
<span class="cm-keyword">function</span> <span class="cm-variable">g</span>(<span class="cm-def">a</span>, <span class="cm-def">b</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable-2">a</span> <span class="cm-operator">*</span> <span class="cm-variable-2">b</span> <span class="cm-operator">*</span> <span class="cm-number">3.5</span>;
}</pre>
<p><a class=p_ident id="p_kjcgm0IFsi" href="#p_kjcgm0IFsi"></a>A key aspect in understanding functions is understanding local scopes.
Parameters and variables declared inside a function are local to the
function, re-created every time the function is called, and not visible
from the outside. Functions declared inside another function have
access to the outer function&#8217;s local scope.</p>
<p><a class=p_ident id="p_Iv45OfFBke" href="#p_Iv45OfFBke"></a>Separating the tasks your program performs into different
functions is helpful. You won&#8217;t have to repeat yourself as much, and
functions can make a program more readable by grouping code into
conceptual chunks, in the same way that chapters and sections help
organize regular text.</p>
<h2><a class=h_ident id="h_TcUD2vzyMe" href="#h_TcUD2vzyMe"></a>Exercises</h2>
<h3><a class=h_ident id="h_XTmO7z7MPq" href="#h_XTmO7z7MPq"></a>Minimum</h3>
<p><a class=p_ident id="p_aW/Uoj4mDd" href="#p_aW/Uoj4mDd"></a>The
<a href="02_program_structure.html#return_values">previous chapter</a>
introduced the standard function <code>Math.min</code> that returns its smallest
argument. We can do that ourselves now. Write a function <code>min</code> that
takes two arguments and returns their minimum.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_gJBIM0zfO9" href="#c_gJBIM0zfO9"></a><span class="cm-comment">// Your code here.</span>

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">min</span>(<span class="cm-number">0</span>, <span class="cm-number">10</span>));
<span class="cm-comment">// → 0</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">min</span>(<span class="cm-number">0</span>, <span class="cm-operator">-</span><span class="cm-number">10</span>));
<span class="cm-comment">// → -10</span></pre>
<div class=solution><div class=solution-text>
<p><a class=p_ident id="p_jbGq7vKDsS" href="#p_jbGq7vKDsS"></a>If you have trouble putting braces and
parentheses in the right place to get a valid function definition,
start by copying one of the examples in this chapter and modifying it.</p>
<p><a class=p_ident id="p_kvKzukD1Sf" href="#p_kvKzukD1Sf"></a>A function may contain multiple <code>return</code>
statements.</p>
</div></div>
<h3><a class=h_ident id="h_jxl1p970Fy" href="#h_jxl1p970Fy"></a>Recursion</h3>
<p><a class=p_ident id="p_iDq2OgBOGw" href="#p_iDq2OgBOGw"></a>We&#8217;ve seen
that <code>%</code> (the remainder operator) can be used to test whether a number
is even or odd by using <code>% 2</code> to check whether it&#8217;s divisible by two.
Here&#8217;s another way to define whether a positive whole number is even
or odd:</p>
<div class="ulist"><ul>
<li>
<p><a class=p_ident id="p_lCOBPDdrEk" href="#p_lCOBPDdrEk"></a>
Zero is even.
</p>
</li>
<li>
<p><a class=p_ident id="p_fWhtKbL+Su" href="#p_fWhtKbL+Su"></a>
One is odd.
</p>
</li>
<li>
<p><a class=p_ident id="p_1dwrqpocrW" href="#p_1dwrqpocrW"></a>
For any other number <em>N</em>, its evenness is the same as <em>N</em> - 2.
</p>
</li>
</ul></div>
<p><a class=p_ident id="p_zxMN8E0WOI" href="#p_zxMN8E0WOI"></a>Define a recursive function <code>isEven</code> corresponding to this
description. The function should accept a <code>number</code> parameter and
return a Boolean.</p>
<p><a class=p_ident id="p_0+fMeza2x5" href="#p_0+fMeza2x5"></a>Test it on 50 and 75. See how it behaves on -1.
Why? Can you think of a way to fix this?</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_QLgWQR2Q0C" href="#c_QLgWQR2Q0C"></a><span class="cm-comment">// Your code here.</span>

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">isEven</span>(<span class="cm-number">50</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">isEven</span>(<span class="cm-number">75</span>));
<span class="cm-comment">// → false</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">isEven</span>(<span class="cm-operator">-</span><span class="cm-number">1</span>));
<span class="cm-comment">// → ??</span></pre>
<div class=solution><div class=solution-text>
<p><a class=p_ident id="p_4Nl1/L8dAN" href="#p_4Nl1/L8dAN"></a>Your
function will likely look somewhat similar to the inner <code>find</code>
function in the recursive <code>findSolution</code>
<a href="03_functions.html#recursive_puzzle">example</a> in this chapter, with
an <code>if</code>/<code>else if</code>/<code>else</code> chain that tests which of the three cases
applies. The final <code>else</code>, corresponding to the third case, makes the
recursive call. Each of the branches should contain a <code>return</code>
statement or in some other way arrange for a specific value to be
returned.</p>
<p><a class=p_ident id="p_QIaN+xYJ+M" href="#p_QIaN+xYJ+M"></a>When given a negative number, the function will
recurse again and again, passing itself an ever more negative number,
thus getting further and further away from returning a result. It will
eventually run out of stack space and abort.</p>
</div></div>
<h3><a class=h_ident id="h_3rsiDgC2do" href="#h_3rsiDgC2do"></a>Bean counting</h3>
<p><a class=p_ident id="p_8y74cOkS91" href="#p_8y74cOkS91"></a>You can get the
Nth character, or letter, from a string by writing
<code>"string".charAt(N)</code>, similar to how you get its length with
<code>"s".length</code>. The returned value will be a string containing only one
character (for example, <code>"b"</code>). The first character has position zero,
which causes the last one to be found at position <code>string.length - 1</code>.
In other words, a two-character string has length 2, and its
characters have positions 0 and 1.</p>
<p><a class=p_ident id="p_3+wBcfMbYR" href="#p_3+wBcfMbYR"></a>Write a function <code>countBs</code> that takes a string as its only argument
and returns a number that indicates how many uppercase “B” characters
are in the string.</p>
<p><a class=p_ident id="p_WdA52+sgwM" href="#p_WdA52+sgwM"></a>Next, write a function called <code>countChar</code> that behaves like <code>countBs</code>,
except it takes a second argument that indicates the character that is
to be counted (rather than counting only uppercase “B” characters).
Rewrite <code>countBs</code> to make use of this new function.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_Xb4A/OaxUr" href="#c_Xb4A/OaxUr"></a><span class="cm-comment">// Your code here.</span>

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">countBs</span>(<span class="cm-string">"BBC"</span>));
<span class="cm-comment">// → 2</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">countChar</span>(<span class="cm-string">"kakkerlak"</span>, <span class="cm-string">"k"</span>));
<span class="cm-comment">// → 4</span></pre>
<div class=solution><div class=solution-text>
<p><a class=p_ident id="p_DGiAPWNd0Y" href="#p_DGiAPWNd0Y"></a>A loop in your function will have
to look at every character in the string by running an index from zero
to one below its length (<code>&lt; string.length</code>). If the character at the
current position is the same as the one the function is looking for,
it adds 1 to a counter variable. Once the loop has finished, the
counter can be returned.</p>
<p><a class=p_ident id="p_vxmtiGDt1B" href="#p_vxmtiGDt1B"></a>Take care to make all the variables used in the
function <em>local</em> to the function by using the <code>var</code> keyword.</p>
</div></div>
<nav>
  <a href="02_program_structure.html" title="capítulo previo">◀</a>
  <a href="index.html" title="cover">◆</a>
  <a href="04_data.html" title="capítulo siguiente">▶</a>
</nav>
</article>
