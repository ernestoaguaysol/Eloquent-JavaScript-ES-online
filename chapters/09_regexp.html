<!doctype html>
<head>
  <meta charset="utf-8">
  <title>Expresiones Regulares :: Eloquent JavaScript</title>
  <link rel=stylesheet href="js/node_modules/codemirror/lib/codemirror.css">
  <script src="js/acorn_codemirror.js"></script>
  <link rel=stylesheet href="css/ejs.css">
  <script src="js/sandbox.js"></script>
  <script src="js/ejs.js"></script>
  <script>var chapNum = 9;</script>
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-53624335-3', 'auto');
  ga('send', 'pageview');

  </script>
</head>

<article>
<nav>
  <a href="08_error.html" title="capítulo previo">◀</a>
  <a href="index.html" title="cover">◆</a>
  <a href="10_modules.html" title="capítulo siguiente">▶</a>
</nav>

<h1><div class=chap_num>Capítulo 9</div>Expresiones Regulares</h1>
<blockquote>
<p><a class=p_ident id="p_48rajKViXI" href="#p_48rajKViXI"></a>Algunas personas, cuando se enfrentan a un problema, dicen <em>ya sé, usaré expresiones regulares</em>. entonces tienen dos problemas.</p>
 <footer>Jamie Zawinski</footer>
</blockquote>
<blockquote>
<p><a class=p_ident id="p_AtlL1szxQa" href="#p_AtlL1szxQa"></a>Yuan-Ma dijo: "Cuando se corta contra la veta de la madera, se necesita mucha fuerza. Cuando se programa contra la lógica de un problema, se necesita mucho código."</p>
 <footer>Master Yuan-Ma, <cite>The Book of Programming</cite></footer>
</blockquote>
<p><a class=p_ident id="p_05EHwYJnbE" href="#p_05EHwYJnbE"></a>Las herramientas y técnicas de programación sobreviven y se propagan de una manera caótica y evolutiva. No siempre son las formas mas bonitas y luminosos las que ganan, sino las que funcionan lo suficientemente bien en el nicho adecuado. Por ejemplo, aquellas que estan correctamente integrada con otra pieza tecnologica.</p>
<p><a class=p_ident id="p_FlQ8p4rQRY" href="#p_FlQ8p4rQRY"></a>En este capítulo, hablaré de una de esas herramientas, las expresiones regulares. Las expresiones regulares son una forma de describir patrones en los datos tipo cadena. Forman un lenguaje pequeño y separado que forma parte de JavaScript y muchos otros idiomas y herramientas.</p>
<p><a class=p_ident id="p_3anzmQulrj" href="#p_3anzmQulrj"></a>Las expresiones regulares son terriblemente incómodas y extremadamente útiles. Su sintaxis es críptica, y la interfaz de programación que proporciona JavaScript es torpe. Pero son una poderosa herramienta para inspeccionar y procesar cadenas. La correcta comprensión de expresiones regulares le hará un programador más eficaz.</p>
<h2><a class=h_ident id="h_uzZ161IWoA" href="#h_uzZ161IWoA"></a>Creación de una expresión regular</h2>
<p><a class=p_ident id="p_QCUtFEqhZs" href="#p_QCUtFEqhZs"></a>Una expresión regular es un tipo de objeto. Puede construirse con el constructor <code>_RegExp_</code> o escribirse como un valor literal encerrando el patrón en caracteres de barra diagonal (<code>_/_</code>).</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_XBSA9s2btm" href="#c_XBSA9s2btm"></a><span class="cm-keyword">var</span> <span class="cm-variable">re1</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">RegExp</span>(<span class="cm-string">"abc"</span>);
<span class="cm-keyword">var</span> <span class="cm-variable">re2</span> <span class="cm-operator">=</span> <span class="cm-string-2">/abc/</span>;</pre>
<p><a class=p_ident id="p_Fz6ODF3XJG" href="#p_Fz6ODF3XJG"></a>Ambos objetos de expresión regular representan el mismo patrón pattern: un carácter <em>a</em> seguido de un <em>b</em> seguido de un <em>c</em>.</p>
<p><a class=p_ident id="p_AD2f7pq4at" href="#p_AD2f7pq4at"></a>Cuando se utiliza el constructor <code>_RegExp_</code>, el patrón se escribe como una cadena normal, por lo que se aplican las reglas habituales para las barras invertidas.</p>
<p><a class=p_ident id="p_NHnJE9bm45" href="#p_NHnJE9bm45"></a>La segunda notación, donde el patrón aparece entre los caracteres de barra (<code>_/_</code>), trata las barras inversas de manera algo diferente. En primer lugar, ya que una barra inclinada termina el patrón, necesitamos poner una barra invertida antes de cualquier barra inclinada que queramos ser parte del patrón. Además, las barras invertidas que no forman parte de códigos de caracteres especiales (como <code>_\n_</code>) se conservarán, en lugar de ignorarse como están en cadenas, y cambiaran el significado del patrón. Algunos caracteres, como signos de interrogación (<code>_?_</code>) y signos más (<code>_+_</code>), tienen significados especiales en expresiones regulares y deben estar precedidos por una barra invertida si están destinados a representar el carácter en sí.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_GMbBpgLwwd" href="#c_GMbBpgLwwd"></a><span class="cm-keyword">var</span> <span class="cm-variable">eighteenPlus</span> <span class="cm-operator">=</span> <span class="cm-string-2">/eighteen\+/</span>;</pre>
<p><a class=p_ident id="p_nN7XVhP/HX" href="#p_nN7XVhP/HX"></a>Saber cuales carácteres deben usar la barra invertida y cuales no al momento que se escriben expresiones regulares requiere que usted conozca a cada uno de los carácteres especiales. Como en un principio esto puede ser muy engorroso, es recomendable que en caso de duda, sólo ponga una barra invertida antes de cualquier carácter que no sea una letra, número o espacio en blanco.</p>
<h2><a class=h_ident id="h_qaLip5xmn/" href="#h_qaLip5xmn/"></a>Testeando las coincidencias (matches)</h2>
<p><a class=p_ident id="p_E7RyDOX7gE" href="#p_E7RyDOX7gE"></a> Los objetos de expresiones regulares tienen varios métodos. El más simple es <code>_test_</code>. Si le pasas una cadena, devolverá un booleano diciéndote si la cadena contiene una coincidencia con el patrón de la expresión propuesta.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_zeXAgGBb93" href="#c_zeXAgGBb93"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/abc/</span>.<span class="cm-property">test</span>(<span class="cm-string">"abcde"</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/abc/</span>.<span class="cm-property">test</span>(<span class="cm-string">"abxde"</span>));
<span class="cm-comment">// → false</span></pre>
<p><a class=p_ident id="p_2vK1tM6fRK" href="#p_2vK1tM6fRK"></a>Una expresión regular que consta sólo de caracteres no especiales representa simplemente esa secuencia de caracteres. Si “abc” se produce en cualquier parte de la cadena que estamos probando (no sólo al principio), el metodo <code>_test_</code> devolverá <code>_true_</code>.</p>
<h2><a class=h_ident id="h_5xC89cwpPd" href="#h_5xC89cwpPd"></a>Matchear un conjunto de caracteres</h2>
<p><a class=p_ident id="p_z3JS3xx91L" href="#p_z3JS3xx91L"></a> Descubrir si una cadena contiene <em>abc</em> podría hacerse con una llamada al método <code>_indexOf_</code>. Las expresiones regulares nos permiten ir más allá y expresar patrones más complicados.</p>
<p><a class=p_ident id="p_Eh18fULy+Q" href="#p_Eh18fULy+Q"></a>Digamos que queremos buscar en una cadena cualquier número del 0 al 9. En una expresión regular, poner un conjunto de caracteres entre corchetes (<code>_[]_</code>) hace en la expresión de destino busque coincidencias con cualquiera de los caracteres entre los corchetes.</p>
<p><a class=p_ident id="p_Yv5ZMIpsdv" href="#p_Yv5ZMIpsdv"></a>Las dos expresiones siguientes coinciden con todas las cadenas que contienen un dígito:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_HVuMjrCPml" href="#c_HVuMjrCPml"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/[0123456789]/</span>.<span class="cm-property">test</span>(<span class="cm-string">"in 1992"</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/[0-9]/</span>.<span class="cm-property">test</span>(<span class="cm-string">"in 1992"</span>));
<span class="cm-comment">// → true</span></pre>
<p><a class=p_ident id="p_3wiPWLrjmt" href="#p_3wiPWLrjmt"></a> Entre corchetes, se puede utilizar un guión (<code>_-_</code>) entre dos caracteres para indicar un rango, donde el orden se determina por el número Unicode de cada cáracter. Como los caracteres <code>_0_</code> a <code>_9_</code> se sitúan uno al lado del otro en este orden (códigos 48 a 57), entonces <code>_[0-9]_</code> cubre todos ellos y coincide con cualquier dígito.</p>
<p><a class=p_ident id="p_6vEnTPj+KP" href="#p_6vEnTPj+KP"></a>Hay una serie de grupos de caracteres comunes que tienen sus propios atajos incorporados. Los dígitos son uno de ellos: <code>_\d_</code> significa lo mismo que <code>_[0-9]_</code>.</p>
<table>
<tr>
<td><code>\d</code></td>
<td>Cualquier carácter de dígito</td>
</tr>
<tr>
<td><code>\w</code></td>
<td>Un carácter alfanumérico (carácter de texto o (“<em>word character</em>”)</td>
</tr>
<tr>
<td><code>\s</code></td>
<td>Cualquier espacio en blanco (espacio, pestaña, nueva línea y similar)</td>
</tr>
<tr>
<td><code>\D</code></td>
<td>Carácter que <em>no</em> es un dígito</td>
</tr>
<tr>
<td><code>\W</code></td>
<td>Un carácter no alfanumérico</td>
</tr>
<tr>
<td><code>\S</code></td>
<td>Un carácter no-espacio-en-blanco</td>
</tr>
<tr>
<td><code>.</code></td>
<td>Cualquier carácter excepto carácter de nueva línea</td>
</tr>
</table>
<p><a class=p_ident id="p_xCCGEvhUuB" href="#p_xCCGEvhUuB"></a>Así que se podría coincidir (<em>matchear</em>) con un formato de fecha y hora como 30-01-2003 15:20 con la siguiente expresión:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_qEjIHbiUGM" href="#c_qEjIHbiUGM"></a><span class="cm-keyword">var</span> <span class="cm-variable">dateTime</span> <span class="cm-operator">=</span> <span class="cm-string-2">/\d\d-\d\d-\d\d\d\d \d\d:\d\d/</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">dateTime</span>.<span class="cm-property">test</span>(<span class="cm-string">"30-01-2003 15:20"</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">dateTime</span>.<span class="cm-property">test</span>(<span class="cm-string">"30-jan-2003 15:20"</span>));
<span class="cm-comment">// → false</span></pre>
<p><a class=p_ident id="p_XeHZm27c++" href="#p_XeHZm27c++"></a>Se ve horrible, ¿verdad? Tiene demasiadas barras invertidas y es difícil detectar el patrón real expresado. Veremos una versión ligeramente mejorada de esta expresión más adelante <a href="09_regexp.html#date_regexp_counted">más adelante</a>.</p>
<p><a class=p_ident id="p_WzljPMXxWf" href="#p_WzljPMXxWf"></a>Estos códigos de barra invertida también se pueden utilizar dentro de corchetes. Por ejemplo, <code>_[\ d.]_</code> significa cualquier dígito o un carácter de período. Pero tenga en cuenta que el propio período, cuando se usa entre corchetes, pierde su significado especial. Lo mismo ocurre con otros caracteres especiales, como <code>_+_</code>.</p>
<p><a class=p_ident id="p_UfEuOyZI/2" href="#p_UfEuOyZI/2"></a>Para <em>invertir</em> un conjunto de caracteres, es decir, para expresar que desea que coincida con cualquier carácter <em>excepto</em> los del conjunto, puede escribir (<code>^</code>) después del corchete de apertura.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_X+leI8mnDf" href="#c_X+leI8mnDf"></a><span class="cm-keyword">var</span> <span class="cm-variable">notBinary</span> <span class="cm-operator">=</span> <span class="cm-string-2">/[^01]/</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">notBinary</span>.<span class="cm-property">test</span>(<span class="cm-string">"1100100010100110"</span>));
<span class="cm-comment">// → false</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">notBinary</span>.<span class="cm-property">test</span>(<span class="cm-string">"1100100010200110"</span>));
<span class="cm-comment">// → true</span></pre>
<h2><a class=h_ident id="h_ca3hUPuf+i" href="#h_ca3hUPuf+i"></a>Repitiendo partes de un patrón</h2>
<p><a class=p_ident id="p_uDAQc+XR+9" href="#p_uDAQc+XR+9"></a>Ya sabemos cómo hacer coincidir un solo dígito. ¿Qué pasa si queremos igualar un número entero? ¿Una secuencia de uno o más dígitos?</p>
<p><a class=p_ident id="p_EbyoLS2v6u" href="#p_EbyoLS2v6u"></a> Cuando se coloca un signo más (<code>_+_</code>) después de algo en una expresión regular, indica que el elemento se puede repetir más de una vez. Así, <code>_/\d+/_</code> coincide con uno o más caracteres de dígito.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_BYI6qYvAV/" href="#c_BYI6qYvAV/"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/'\d+'/</span>.<span class="cm-property">test</span>(<span class="cm-string">"'123'"</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/'\d+'/</span>.<span class="cm-property">test</span>(<span class="cm-string">"''"</span>));
<span class="cm-comment">// → false</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/'\d*'/</span>.<span class="cm-property">test</span>(<span class="cm-string">"'123'"</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/'\d*'/</span>.<span class="cm-property">test</span>(<span class="cm-string">"''"</span>));
<span class="cm-comment">// → true</span></pre>
<p><a class=p_ident id="p_Yo8guZgpLO" href="#p_Yo8guZgpLO"></a>El asterisco (<em><code><strong></code>_) tiene un significado similar, pero también permite que el patrón coincida cero veces. Algo con un _<code></strong></code></em> al final, nunca impide un patrón de emparejamiento. Igualará cero instancias si no puede encontrar cualquier texto adecuado al patrón.</p>
<p><a class=p_ident id="p_84KusXsF/T" href="#p_84KusXsF/T"></a>Un signo de interrogación (<em><code>?</code></em>) hace que una parte de un patrón sea "opcional", lo que significa que puede ocurrir ninguna o una vez. En el ejemplo siguiente, se permite que el carácter <em>u</em> se produzca, pero el patrón también coincide (<em>matchea</em>) cuando este falta.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_6Xf61OFixQ" href="#c_6Xf61OFixQ"></a><span class="cm-keyword">var</span> <span class="cm-variable">neighbor</span> <span class="cm-operator">=</span> <span class="cm-string-2">/neighbou?r/</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">neighbor</span>.<span class="cm-property">test</span>(<span class="cm-string">"neighbour"</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">neighbor</span>.<span class="cm-property">test</span>(<span class="cm-string">"neighbor"</span>));
<span class="cm-comment">// → true</span></pre>
<p><a class=p_ident id="p_pQrIOoMzrK" href="#p_pQrIOoMzrK"></a>Para indicar que un patrón debe ocurrir un número exacto de veces, utilice llaves (_<code>{}</code>_). Poner `_{4}_<code> después de un elemento, por ejemplo, indica que se requiere que el elemento se encuentre (o matchee) exactamente cuatro veces. También es posible especificar un rango de esta manera: </code>_{2,4}_` significa que el elemento debe ocurrir al menos dos veces y como máximo cuatro veces.</p>
<p id="date_regexp_counted"><a class=p_ident id="p_kRhn4dkJRq" href="#p_kRhn4dkJRq"></a>Aquí hay otra versión del patrón de fecha y hora que permite los días, meses y horas de un solo dígito y dos dígitos, lo que lo hace más agradable y fácil de leer.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_gt5q3xImkE" href="#c_gt5q3xImkE"></a><span class="cm-keyword">var</span> <span class="cm-variable">dateTime</span> <span class="cm-operator">=</span> <span class="cm-string-2">/\d{1,2}-\d{1,2}-\d{4} \d{1,2}:\d{2}/</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">dateTime</span>.<span class="cm-property">test</span>(<span class="cm-string">"30-1-2003 8:45"</span>));
<span class="cm-comment">// → true</span></pre>
<p><a class=p_ident id="p_BfOD6QWfFj" href="#p_BfOD6QWfFj"></a>También puede especificar rangos abiertos cuando se usan llaves, omitiendo el número después de la coma. Así que <code>_{5,}_</code> significa cinco o más veces.</p>
<h2><a class=h_ident id="h_mHv5mA8W0l" href="#h_mHv5mA8W0l"></a>Agrupar subexpresiones</h2>
<p><a class=p_ident id="p_tiF4w6yN9y" href="#p_tiF4w6yN9y"></a>Para usar un operador como <code>_*_</code> o <code>_+_</code> en más de un elemento a la vez, puede utilizar paréntesis <code>_()_</code>. Una parte de una expresión regular que está encerrada entre paréntesis cuenta como un solo elemento en lo que se refiere a los operadores que lo siguen.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_kHQZThMKOE" href="#c_kHQZThMKOE"></a><span class="cm-keyword">var</span> <span class="cm-variable">cartoonCrying</span> <span class="cm-operator">=</span> <span class="cm-string-2">/boo+(hoo+)+/i</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">cartoonCrying</span>.<span class="cm-property">test</span>(<span class="cm-string">"Boohoooohoohooo"</span>));
<span class="cm-comment">// → true</span></pre>
<p><a class=p_ident id="p_84+Tl0hOd2" href="#p_84+Tl0hOd2"></a>El primer <code>_+_</code> y el segundo <code>_+_</code> se aplican solamente al segundo <code>_o_</code> en <code>_boo_</code> y <code>_hoo_</code>, respectivamente. El tercero <code>_+_</code> se aplica a todo el grupo <code>_(hoo+)_</code>, haciendo coincidir una o más secuencias como esa.</p>
<p><a class=p_ident id="p_3ClVACorrE" href="#p_3ClVACorrE"></a>El <code>_i_</code> al final de la expresión en el ejemplo anterior hace que esta expresi��n regular no sea sensible a mayúsculas y minúsculas  (case insensitive), permitiendo que coincida con la mayúscula <em>B</em> en la cadena de entrada, aunque el patrón es todo en minúsculas.</p>
<h2><a class=h_ident id="h_rxuNUTGwQ+" href="#h_rxuNUTGwQ+"></a>Matcheos y grupos</h2>
<p><a class=p_ident id="p_dgr/mPgWei" href="#p_dgr/mPgWei"></a>El método <code>_test_</code> es la forma más simple de buscar coincidencias con una expresión regular. Sólo dice si coincide y nada más. Las expresiones regulares también tienen un método <code>_exec_</code> (ejecutar) que devolverá <code>_null_</code> si no se encontró ninguna coincidencia o, si encontró una,  devolverá un objeto con información sobre la coincidencia.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_AbqNRdvP1O" href="#c_AbqNRdvP1O"></a><span class="cm-keyword">var</span> <span class="cm-variable">match</span> <span class="cm-operator">=</span> <span class="cm-string-2">/\d+/</span>.<span class="cm-property">exec</span>(<span class="cm-string">"one two 100"</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">match</span>);
<span class="cm-comment">// → ["100"]</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">match</span>.<span class="cm-property">index</span>);
<span class="cm-comment">// → 8</span></pre>
<p><a class=p_ident id="p_MEyBiymd+J" href="#p_MEyBiymd+J"></a>Un objeto devuelto desde el método <code>_exec_</code> tiene una propiedad <code>_índex_</code> que nos dice en dónde comienza la coincidencia correcta en la cadena. Aparte de eso, el objeto se ve como (y de hecho es) una matriz de cadenas, cuyo primer elemento es la cadena que matcheó (en el ejemplo anterior, ésta es la secuencia de dígitos que estábamos buscando).</p>
<p><a class=p_ident id="p_e2o3R6JZyN" href="#p_e2o3R6JZyN"></a>Los valores de cadena tienen un método <code>_match_</code> de coincidencia que se comporta de manera similar.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_8nDeiJq81E" href="#c_8nDeiJq81E"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"one two 100"</span>.<span class="cm-property">match</span>(<span class="cm-string-2">/\d+/</span>));
<span class="cm-comment">// → ["100"]</span></pre>
<p><a class=p_ident id="p_mvGBAzey4W" href="#p_mvGBAzey4W"></a>Cuando la expresión regular contiene subexpresiones agrupadas con paréntesis, el texto que coincida con esos grupos también aparecerá en la matriz. Todo el <code>_match_</code> es siempre el primer elemento. El siguiente elemento es la parte que coincidió por el primer grupo (aquel cuyo paréntesis de apertura viene primero en la expresión), luego el segundo grupo, y así sucesivamente.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_6pRF1wi/LY" href="#c_6pRF1wi/LY"></a><span class="cm-keyword">var</span> <span class="cm-variable">quotedText</span> <span class="cm-operator">=</span> <span class="cm-string-2">/'([^']*)'/</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">quotedText</span>.<span class="cm-property">exec</span>(<span class="cm-string">"she said 'hello'"</span>));
<span class="cm-comment">// → ["'hello'", "hello"]</span></pre>
<p><a class=p_ident id="p_WN9YS5S7hb" href="#p_WN9YS5S7hb"></a>Cuando un grupo no encuentra coincidencia en absoluto (por ejemplo, cuando es seguido por un signo de interrogación), su posición en la matriz de salida se mantendrá indefinida. Del mismo modo, cuando un grupo es matcheado varias veces, sólo el último match termina en la matriz.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_gdBmQs+8eG" href="#c_gdBmQs+8eG"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/bad(ly)?/</span>.<span class="cm-property">exec</span>(<span class="cm-string">"bad"</span>));
<span class="cm-comment">// → ["bad", undefined]</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/(\d)+/</span>.<span class="cm-property">exec</span>(<span class="cm-string">"123"</span>));
<span class="cm-comment">// → ["123", "3"]</span></pre>
<p><a class=p_ident id="p_yb0zOxY3YF" href="#p_yb0zOxY3YF"></a>Los grupos pueden ser útiles para extraer partes de una cadena. Si no queremos solamente verificar si una cadena contiene una fecha sino también queremos extraerla y construir un objeto que la represente, podemos insertar paréntesis alrededor de los patrones de dígitos y escoger directamente la fecha del resultado de <code>_exec_</code>.</p>
<p><a class=p_ident id="p_hrz9Lx8p81" href="#p_hrz9Lx8p81"></a>Pero primero, un breve desvío en el que discutimos la forma preferida de almacenar valores de fecha y hora en JavaScript.</p>
<h2><a class=h_ident id="h_E43gxtOTeh" href="#h_E43gxtOTeh"></a>El tipo fecha</h2>
<p><a class=p_ident id="p_XmKwgP+C+/" href="#p_XmKwgP+C+/"></a>JavaScript tiene un tipo (<code>_typeof_</code>) de objeto estándar para representar fechas, o más bien, puntos en el tiempo. Se llama <code>_Date_</code>. Si simplemente se crea un objeto <code>_Date_</code> con <code>_new_</code>, se obtienen la fecha y la hora actual.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_4/QwmvfzeT" href="#c_4/QwmvfzeT"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Date</span>());
<span class="cm-comment">// → Wed Dec 04 2013 14:24:57 GMT+0100 (CET)</span></pre>
<p><a class=p_ident id="p_CuttKILZ4B" href="#p_CuttKILZ4B"></a>También puede crear un objeto para una hora específica.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_Axg4c01Yic" href="#c_Axg4c01Yic"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Date</span>(<span class="cm-number">2009</span>, <span class="cm-number">11</span>, <span class="cm-number">9</span>));
<span class="cm-comment">// → Wed Dec 09 2009 00:00:00 GMT+0100 (CET)</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Date</span>(<span class="cm-number">2009</span>, <span class="cm-number">11</span>, <span class="cm-number">9</span>, <span class="cm-number">12</span>, <span class="cm-number">59</span>, <span class="cm-number">59</span>, <span class="cm-number">999</span>));
<span class="cm-comment">// → Wed Dec 09 2009 12:59:59 GMT+0100 (CET)</span></pre>
<p><a class=p_ident id="p_B9NxarrX92" href="#p_B9NxarrX92"></a>JavaScript utiliza una convención donde los números de mes empiezan en cero (por lo que diciembre es 11), sin embargo, los números de día empiezan en uno. Esto puede ser muy confuso y tonto. Ten mucho cuidado.</p>
<p><a class=p_ident id="p_2J32V8P3Ua" href="#p_2J32V8P3Ua"></a>Los últimos cuatro argumentos (horas, minutos, segundos y milisegundos) son opcionales y se toman como cero cuando no se dan.</p>
<p><a class=p_ident id="p_WZ6xJ/ztd1" href="#p_WZ6xJ/ztd1"></a>Las marcas de tiempo se almacenan como el número de milisegundos desde el comienzo de 1970, usando números negativos para tiempos anteriores a 1970 (siguiendo una convención establecida por “Unix time” creada en esa decada). El método <code>_getTime_</code> en un objeto de <code>_Date_</code> devuelve este número. Es un número grande.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_vaHFZIeEA4" href="#c_vaHFZIeEA4"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Date</span>(<span class="cm-number">2013</span>, <span class="cm-number">11</span>, <span class="cm-number">19</span>).<span class="cm-property">getTime</span>());
<span class="cm-comment">// → 1387407600000</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Date</span>(<span class="cm-number">1387407600000</span>));
<span class="cm-comment">// → Thu Dec 19 2013 00:00:00 GMT+0100 (CET)</span></pre>
<p><a class=p_ident id="p_6SK4LCaLRD" href="#p_6SK4LCaLRD"></a>Si le da al constructor <code>_Date_</code> un solo argumento, ese argumento se trata como un recuento de milisegundos. Puede obtener el recuento actual de milisegundos creando un nuevo objeto <code>_Date_</code> y llamando a <code>_getTime_</code>, pero también llamando a la función <code>_Date.now_</code>.</p>
<p><a class=p_ident id="p_ap8RJHSLRn" href="#p_ap8RJHSLRn"></a>Los objetos <code>_Date_</code> proporcionan métodos como <code>_getFullYear_</code>, <code>_getMonth_</code>, <code>_getDate_</code>, <code>_getHours_</code>, <code>_getMinutes_</code> y <code>_getSeconds_</code> para extraer sus componentes. También hay un método <code>_getYear_</code> que da un valor de año de dos dígitos bastante inútil (como 93 o 14).</p>
<p><a class=p_ident id="p_eA5U6lb8Dx" href="#p_eA5U6lb8Dx"></a>Poniendo paréntesis alrededor de las partes de la expresión que nos interesa, ahora podemos crear fácilmente un objeto <code>_Date_</code> a partir de una cadena.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_7pmUT9r1B8" href="#c_7pmUT9r1B8"></a><span class="cm-keyword">function</span> <span class="cm-variable">findDate</span>(<span class="cm-def">string</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">dateTime</span> <span class="cm-operator">=</span> <span class="cm-string-2">/(\d{1,2})-(\d{1,2})-(\d{4})/</span>;
  <span class="cm-keyword">var</span> <span class="cm-def">match</span> <span class="cm-operator">=</span> <span class="cm-variable-2">dateTime</span>.<span class="cm-property">exec</span>(<span class="cm-variable-2">string</span>);
  <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">Date</span>(<span class="cm-variable">Number</span>(<span class="cm-variable-2">match</span>[<span class="cm-number">3</span>]),
                  <span class="cm-variable">Number</span>(<span class="cm-variable-2">match</span>[<span class="cm-number">2</span>]) <span class="cm-operator">-</span> <span class="cm-number">1</span>,
                  <span class="cm-variable">Number</span>(<span class="cm-variable-2">match</span>[<span class="cm-number">1</span>]));
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">findDate</span>(<span class="cm-string">"30-1-2003"</span>));
<span class="cm-comment">// → Thu Jan 30 2003 00:00:00 GMT+0100 (CET)</span></pre>
<h2><a class=h_ident id="h_26ixny78VY" href="#h_26ixny78VY"></a>Limitar palabras y cadenas</h2>
<p><a class=p_ident id="p_F5bbhTiM7z" href="#p_F5bbhTiM7z"></a>Desafortunadamente, <code>_findDate_</code> también obtendra fechas sin sentido del tipo 00-1-3000 de la cadena <em>"100-1-30000"</em>. Una coincidencia puede ocurrir en cualquier parte de la cadena, por lo que en este caso, sólo comenzará en el segundo carácter y finalizará en el segundo al último carácter.</p>
<p><a class=p_ident id="p_RlQsbUbd6S" href="#p_RlQsbUbd6S"></a>Si queremos hacer que la coincidencia abarque toda la cadena, podemos agregar los marcadores <em><code><sup></code>_ y _<code>$</code>_. El _<code></sup></code>_ coincide con el inicio de la cadena de entrada, mientras que _<code>$</code>_ coincide con el final. Por lo tanto, _<code>/<sup>\d+$/</code>_ coincide con una cadena compuesta enteramente de uno o más dígitos, _<code>/</sup>!/</code>_ coincide con cualquier cadena que comience con un signo de exclamación y _<code>/x^/</code></em> no coincide con ninguna cadena (no puede haber una <em><code>x</code></em> antes el comienzo de la cadena).</p>
<p><a class=p_ident id="p_h+UmRPAPSb" href="#p_h+UmRPAPSb"></a>Si, por el contrario, sólo queremos asegurarnos de que la fecha empiece y termine en un límite de palabra, podemos usar el marcador <em><code>\b</code></em>. Un límite de palabra puede ser el comienzo o el final de la cadena o cualquier punto de la cadena que tenga un carácter de palabra (como en <em><code>\w</code></em>) en un lado y un carácter <em><code>nonword</code></em> en el otro.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_SERrM1AMQn" href="#c_SERrM1AMQn"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/cat/</span>.<span class="cm-property">test</span>(<span class="cm-string">"concatenate"</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/\bcat\b/</span>.<span class="cm-property">test</span>(<span class="cm-string">"concatenate"</span>));
<span class="cm-comment">// → false</span></pre>
<p><a class=p_ident id="p_O3hJLo5Zsc" href="#p_O3hJLo5Zsc"></a>Tenga en cuenta que un marcador de límite no representa un carácter real. Sólo hace que la expresión regular coincida solamente si una determinada condición se mantiene donde aparece en el patrón.</p>
<h2><a class=h_ident id="h_TUSc554JnM" href="#h_TUSc554JnM"></a>Patrones de elección</h2>
<p><a class=p_ident id="p_nrCHXQ79Ba" href="#p_nrCHXQ79Ba"></a>Digamos que no queremos saber si una parte del texto contiene un número, sino que buscamos un número seguido por una de las palabras <em>pig</em>, <em>cow</em> o <em>chicken</em>, o cualquiera de sus formas plurales.</p>
<p><a class=p_ident id="p_faCL6B9cwG" href="#p_faCL6B9cwG"></a>Podríamos escribir tres expresiones regulares y probarlas a su vez, pero hay una manera más agradable. El carácter <em>|</em> (tubo) indica una opción entre el patrón a su izquierda y el patrón a su derecha. Así que puedo decir esto:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_Z/F4sBfNoS" href="#c_Z/F4sBfNoS"></a><span class="cm-keyword">var</span> <span class="cm-variable">animalCount</span> <span class="cm-operator">=</span> <span class="cm-string-2">/\b\d+ (pig|cow|chicken)s?\b/</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">animalCount</span>.<span class="cm-property">test</span>(<span class="cm-string">"15 pigs"</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">animalCount</span>.<span class="cm-property">test</span>(<span class="cm-string">"15 pigchickens"</span>));
<span class="cm-comment">// → false</span></pre>
<p><a class=p_ident id="p_js4LlOVlLE" href="#p_js4LlOVlLE"></a>Los paréntesis <em>()</em> se pueden usar para limitar la parte del patrón a la que se aplica el operador <em>|</em> (tubo) y se pueden poner varios operadores de este tipo, uno al lado del otro, para expresar opciones entre más de dos patrones.</p>
<h2><a class=h_ident id="h_YbvaiKYL6o" href="#h_YbvaiKYL6o"></a>La mecánica del matcheo o coincidencia</h2>
<p><a class=p_ident id="p_1hzyEqol6G" href="#p_1hzyEqol6G"></a>Las expresiones regulares pueden considerarse diagramas de flujo. Este es el diagrama para el ejemplo anterior:</p>
<div class="image">
  <img src="img/re_pigchickens.svg" alt="Visualization of /\b\d+ (pig|cow|chicken)s?\b/">
</div>
<p><a class=p_ident id="p_YKIIKxAXKQ" href="#p_YKIIKxAXKQ"></a>Nuestra expresión coincide (<em>matchea</em>) con una cadena de caracteres si podemos seguir el camino desde el lado izquierdo del diagrama hacia el lado derecho. Mantenemos una posición en la cadena y, cada vez que nos movemos a través de una caja, verificamos que la parte de la cadena que dejamos atras coincide con dicha casilla.</p>
<p><a class=p_ident id="p_dBpeZP7Lz9" href="#p_dBpeZP7Lz9"></a>Así que si tratamos de matchear <code>"the 3 pigs"</code> con nuestra expresión regular, nuestro progreso a través del diagrama de flujo sería así:</p>
<div class="ulist"><ul>
<li>
<p><a class=p_ident id="p_wgyBFgE+AM" href="#p_wgyBFgE+AM"></a>
En la posición 4, hay un límite de palabras <em>boundary</em>, por lo que podemos pasar de la primera casilla.
</p>
</li>
<li>
<p><a class=p_ident id="p_WWMhGacaDr" href="#p_WWMhGacaDr"></a>
Todavía en la posición 4, encontramos un dígito, así que también podemos pasar de la segunda caja.
</p>
</li>
<li>
<p><a class=p_ident id="p_l9lpVySNJr" href="#p_l9lpVySNJr"></a>
En la posición 5, un camino recorre hacia antes de la segunda (dígito) caja, mientras que el otro se mueve hacia adelante a través de la caja que contiene un solo carácter de espacio. Hay un espacio aquí, no un dígito, así que debemos tomar el segundo camino.
</p>
</li>
<li>
<p><a class=p_ident id="p_DQb7puPaWG" href="#p_DQb7puPaWG"></a>
Ahora estamos en la posición 6 (el comienzo de "<em>pigs</em>") y en la rama de tres vías en el diagrama. No vemos "<em>cow</em>" o "<em>chiken</em>" aquí, pero sí vemos "<em>pig</em>", así que tomamos esa rama.
</p>
</li>
<li>
<p><a class=p_ident id="p_CeOVj5OJoW" href="#p_CeOVj5OJoW"></a>
En la posición 9, después de la rama de tres vías, una ruta omite la caja <em>s</em> y va directamente al límite final de la palabra, mientras que la otra ruta coincide con una <em>s</em>. Hay un carácter de s aquí, no una frontera de la palabra, así que vamos a través de la caja de <em>s</em>.
</p>
</li>
<li>
<p><a class=p_ident id="p_TiBKAjpnbZ" href="#p_TiBKAjpnbZ"></a>
Estamos en la posición 10 (el final de la cadena) y puede coincidir sólo con un límite de palabra <em>boundary</em>. El final de una cadena cuenta como un límite de palabra, por lo que pasamos por el último cuadro y hemos <em>matcheado</em> con esta cadena..
</p>
</li>
</ul></div>
<p><a class=p_ident id="p_z0U50Oo802" href="#p_z0U50Oo802"></a>Conceptualmente, un motor de expresiones regulares busca una coincidencia en una cadena de la siguiente manera: comienza al principio de la cadena e intenta una coincidencia allí. En este caso, hay un límite de palabra (<em>word boundary</em>) allí, por lo que pasaría la primera casilla, pero no hay dígitos, por lo que fallaría en la segunda casilla. Luego se mueve al segundo carácter de la cadena e intenta comenzar un nuevo partido allí... y así sucesivamente, hasta que encuentre una coincidencia o llegue al final de la cadena y decida que realmente no hay coincidencia.</p>
<h2 id="backtracking"><a class=h_ident id="h_nmeiqrCjN8" href="#h_nmeiqrCjN8"></a>Retroceso</h2>
<p><a class=p_ident id="p_QOY2sD8j/J" href="#p_QOY2sD8j/J"></a>La expresión regular <code>_/\b([01]+b|\d+|[\da-f]+h)\b/_</code> coincide con un número binario seguido de <em>a b</em>, un número decimal regular sin carácter de sufijo o un número hexadecimal (Es decir, base 16, con las letras de <em>a - f</em> para representar dígitos <em>10</em> a <em>15</em>) seguido de <em>h</em>. Este es el diagrama correspondiente:</p>
<div class="image">
  <img src="img/re_number.svg" alt="Visualization of /\b([01]+b|\d+|[\da-f]+h)\b/">
</div>
<p><a class=p_ident id="p_Z9elkeCPuf" href="#p_Z9elkeCPuf"></a>Al hacer coincidir esta expresión, sucederá a menudo que la rama superior (binaria) se ingrese aunque la entrada no contenga realmente un número binario. Al buscar en la cadena "<em>103</em>", por ejemplo, sólo queda claro en el <em>3</em> que estamos en la rama equivocada. La cadena coincide con la expresión, pero no con la rama en la que estamos actualmente.</p>
<p><a class=p_ident id="p_mUjRUeM4aB" href="#p_mUjRUeM4aB"></a>Así que el <em>matcher</em> retrocede. Al entrar en una rama recuerda su posición actual (en este caso, al comienzo de la cadena, justo después de la primera caja de límites en el diagrama) para que pueda volver atrás y probar otra rama si la actual no funciona. Para la cadena "<em>103</em>", después de encontrar el carácter <em>3</em>, comenzará a probar la rama para los números decimales. Éste coincide, por lo que un <em>match</em> es reportado al final de todo.</p>
<p><a class=p_ident id="p_2drSR2C+CS" href="#p_2drSR2C+CS"></a>El <em>matcher</em> se detiene tan pronto como encuentra una coincidencia completa. Esto significa que si varias ramas podrían potencialmente coincidir con una cadena, sólo se utiliza la primera (ordenada según aparecen en la expresión regular).</p>
<p><a class=p_ident id="p_EVagj0s5dH" href="#p_EVagj0s5dH"></a>El retroceso también ocurre para los operadores de repetición como <code>_+_</code> y <code>_*_</code>. Si coincide con <code>_/^.*x/_</code> contra "<em><code>abcxe</em></code>", la parte <code>_*_</code> Intentará primero consumir toda la cadena. El motor entonces se dará cuenta de que necesita una <code>_x_</code> para que coincida con el patrón. Puesto que no hay <code>_x_</code> superado el final de la cadena, el operador <code>_*_</code> intentara igualar un carácter menos. Pero el <code>_matcher_</code> tampoco encuentra una <code>_x_</code> después de <code>_abcx_</code>, por lo que retrocede de nuevo, haciendo coincidir el operador <code>_*_</code> con <code>_abc_</code>. Ahora si encuentra una <code>_x_</code> donde lo necesita e informa de una coincidencia exitosa desde las posiciones <code>_0_</code> a <code>_4_</code>.</p>
<p><a class=p_ident id="p_QyzQ6Ds3X2" href="#p_QyzQ6Ds3X2"></a>Es posible escribir expresiones regulares con mucho retroceso (<em>backtracking</em>). Esto se produce cuando un patrón puede coincidir con una pieza de entrada de muchas maneras diferentes. Por ejemplo, si nos confundimos al escribir una expresión regular de un número binario, podríamos escribir algo como <code>_/([01]+)+b/_</code>.</p>
<div class="image">
  <img src="img/re_slow.svg" alt="Visualization of /([01]+)+b/">
</div>
<p><a class=p_ident id="p_hZ65XlatCK" href="#p_hZ65XlatCK"></a>Si intenta hacer coincidir una serie larga de ceros y unos sin ningún carácter <em>b</em>, el <em>matcher</em> primero pasará por el bucle interno hasta que se quede sin dígitos. Entonces advierte que no hay <em>b</em>, por lo que retrocede una posición, pasa por el bucle externo una vez, y se da de nuevo, tratando de retroceder fuera del bucle interior una vez más. Seguirá intentando cada ruta posible a través de estos dos bucles. Esto significa que la cantidad de trabajo se duplica con cada carácter adicional. Para incluso sólo unas pocas docenas de caracteres, el <em>matcheo</em> resultante puede ser prácticamente eterno.</p>
<h2><a class=h_ident id="h_nATt9slvSb" href="#h_nATt9slvSb"></a>El método de reemplazo</h2>
<p><a class=p_ident id="p_1ySwSsfW/X" href="#p_1ySwSsfW/X"></a>Los valores de cadena tienen un método <code>_replace_</code>, que se puede usar para reemplazar parte de la cadena con otra cadena.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_8iM5G9/Do0" href="#c_8iM5G9/Do0"></a>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"papa"</span>.<span class="cm-property">replace</span>(<span class="cm-string">"p"</span>, <span class="cm-string">"m"</span>));
<span class="cm-comment">// → mapa</span></pre>
<p><a class=p_ident id="p_yz3fu0YgA5" href="#p_yz3fu0YgA5"></a>El primer argumento también puede ser una expresión regular, en cuyo caso la primera coincidencia de la expresión regular se sustituye. Cuando se agrega una opción <code>_g_</code> (global) a la expresión regular, <em>todas</em> las coincidencias de la cadena se reemplazarán, no sólo la primera.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_Z04SvRJ7Hv" href="#c_Z04SvRJ7Hv"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Borobudur"</span>.<span class="cm-property">replace</span>(<span class="cm-string-2">/[ou]/</span>, <span class="cm-string">"a"</span>));
<span class="cm-comment">// → Barobudur</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Borobudur"</span>.<span class="cm-property">replace</span>(<span class="cm-string-2">/[ou]/g</span>, <span class="cm-string">"a"</span>));
<span class="cm-comment">// → Barabadar</span></pre>
<p><a class=p_ident id="p_9FETptrAYT" href="#p_9FETptrAYT"></a>Hubiera sido razonable si la opción entre reemplazar un solo patrón o todos los patrones se hiciera a través de un argumento adicional o proporcionando un método diferente como <code>_replaceAll_</code>, pero por alguna razón, esta opción se indica en una propiedad de la misma expresión regular.</p>
<p><a class=p_ident id="p_/UBKsstd0w" href="#p_/UBKsstd0w"></a>El poder real de usar expresiones regulares con <code>_replace_</code> viene del hecho de que podemos referirnos de nuevo a los grupos coincidentes en la cadena de reemplazo. Por ejemplo, digamos que tenemos una cadena grande que contiene los nombres de las personas, un nombre por línea, en el formato Apellido, Nombre. Si queremos intercambiar estos nombres y eliminar la coma para obtener un simple formato apellido-nombre, podemos utilizar el siguiente código:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_oV7pPT4bBY" href="#c_oV7pPT4bBY"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(
  <span class="cm-string">"Hopper, Grace\nMcCarthy, John\nRitchie, Dennis"</span>
    .<span class="cm-property">replace</span>(<span class="cm-string-2">/([\w ]+), ([\w ]+)/g</span>, <span class="cm-string">"$2 $1"</span>));
<span class="cm-comment">// → Grace Hopper</span>
<span class="cm-comment">//   John McCarthy</span>
<span class="cm-comment">//   Dennis Ritchie</span></pre>
<p><a class=p_ident id="p_9L44l9sTIK" href="#p_9L44l9sTIK"></a>Los <code>_$1_</code> y <code>_$2_</code> en la cadena de reemplazo se refieren a los grupos entre paréntesis en el patrón. $1 se sustituye por el texto que coincide con el primer grupo, <code>_$2_</code> por el segundo, y así sucesivamente hasta <code>_$9_</code>. Todo el <code>_match_</code> puede ser referido con <code>_$&amp;_</code>.</p>
<p><a class=p_ident id="p_M6lF/LDSEY" href="#p_M6lF/LDSEY"></a>También es posible pasar una función, en lugar de una cadena, como el segundo argumento a reemplazar. Para cada reemplazo, la función se llamará con los grupos coincidentes (así como la coincidencia completa) como argumentos, y su valor de retorno se insertará en la nueva cadena.</p>
<p><a class=p_ident id="p_w/BKfNpnjO" href="#p_w/BKfNpnjO"></a>Aquí hay un ejemplo sencillo:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_hsCV6qp4Dr" href="#c_hsCV6qp4Dr"></a><span class="cm-keyword">var</span> <span class="cm-variable">s</span> <span class="cm-operator">=</span> <span class="cm-string">"the cia and fbi"</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">s</span>.<span class="cm-property">replace</span>(<span class="cm-string-2">/\b(fbi|cia)\b/g</span>, <span class="cm-keyword">function</span>(<span class="cm-def">str</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable-2">str</span>.<span class="cm-property">toUpperCase</span>();
}));
<span class="cm-comment">// → the CIA and FBI</span></pre>
<p><a class=p_ident id="p_2Vgz4PcqzS" href="#p_2Vgz4PcqzS"></a>Y aquí hay una más interesante:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_U+EtsNRLJb" href="#c_U+EtsNRLJb"></a><span class="cm-keyword">var</span> <span class="cm-variable">stock</span> <span class="cm-operator">=</span> <span class="cm-string">"1 lemon, 2 cabbages, and 101 eggs"</span>;
<span class="cm-keyword">function</span> <span class="cm-variable">minusOne</span>(<span class="cm-def">match</span>, <span class="cm-def">amount</span>, <span class="cm-def">unit</span>) {
  <span class="cm-variable-2">amount</span> <span class="cm-operator">=</span> <span class="cm-variable">Number</span>(<span class="cm-variable-2">amount</span>) <span class="cm-operator">-</span> <span class="cm-number">1</span>;
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">amount</span> <span class="cm-operator">==</span> <span class="cm-number">1</span>) <span class="cm-comment">// only one left, remove the 's'</span>
    <span class="cm-variable-2">unit</span> <span class="cm-operator">=</span> <span class="cm-variable-2">unit</span>.<span class="cm-property">slice</span>(<span class="cm-number">0</span>, <span class="cm-variable-2">unit</span>.<span class="cm-property">length</span> <span class="cm-operator">-</span> <span class="cm-number">1</span>);
  <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">amount</span> <span class="cm-operator">==</span> <span class="cm-number">0</span>)
    <span class="cm-variable-2">amount</span> <span class="cm-operator">=</span> <span class="cm-string">"no"</span>;
  <span class="cm-keyword">return</span> <span class="cm-variable-2">amount</span> <span class="cm-operator">+</span> <span class="cm-string">" "</span> <span class="cm-operator">+</span> <span class="cm-variable-2">unit</span>;
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">stock</span>.<span class="cm-property">replace</span>(<span class="cm-string-2">/(\d+) (\w+)/g</span>, <span class="cm-variable">minusOne</span>));
<span class="cm-comment">// → no lemon, 1 cabbage, and 100 eggs</span></pre>
<p><a class=p_ident id="p_re8PUMnhM/" href="#p_re8PUMnhM/"></a>Este ejemplo toma una cadena, encuentra todas las veces que aparece un número seguido de una palabra alfanumérica, y devuelve una cadena (<em>string</em>) en la que cada una de tales apariciones se decrementa en una.</p>
<p><a class=p_ident id="p_Z8aOamH4b+" href="#p_Z8aOamH4b+"></a>El grupo <code>_(\d+)_</code> termina como el argumento <code>_amount_</code> de la función, y el grupo <code>_(\w+)_</code> se vincula al argumento <code>_unit_</code>. La función convierte <code>_amount_</code> en un número -que siempre funciona, ya que coincide con <code>_\d+-_</code> y hace algunos ajustes en caso de que sólo quede uno o cero, como quitar el plural o avisar la falta de stock con la palabra “no”.</p>
<h2><a class=h_ident id="h_Z9SoY0xUbT" href="#h_Z9SoY0xUbT"></a>Codicia</h2>
<p><a class=p_ident id="p_tE1wtVaYQz" href="#p_tE1wtVaYQz"></a>No es difícil utilizar <code>_replace_</code> para escribir una función que elimina todos los comentarios de una pieza de código JavaScript. He aquí un primer intento:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_sVXnzUSoMX" href="#c_sVXnzUSoMX"></a><span class="cm-keyword">function</span> <span class="cm-variable">stripComments</span>(<span class="cm-def">code</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable-2">code</span>.<span class="cm-property">replace</span>(<span class="cm-string-2">/\/\/.*|\/\*[^]*\*\//g</span>, <span class="cm-string">""</span>);
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">stripComments</span>(<span class="cm-string">"1 + /* 2 */3"</span>));
<span class="cm-comment">// → 1 + 3</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">stripComments</span>(<span class="cm-string">"x = 10;// ten!"</span>));
<span class="cm-comment">// → x = 10;</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">stripComments</span>(<span class="cm-string">"1 /* a */+/* b */ 1"</span>));
<span class="cm-comment">// → 1  1</span></pre>
<p><a class=p_ident id="p_aB+eB3XkAV" href="#p_aB+eB3XkAV"></a>La parte anterior al operador <code>_or_</code> (o) simplemente hace coincidir dos caracteres de barra diagonal seguidos de cualquier número de caracteres de no-nueva-línea. La parte para comentarios multilínea está más involucrada. Utilizamos <code>_[^]_</code> (cualquier carácter que no esté en el conjunto vacío de caracteres) como una forma de coincidir con cualquier carácter. No podemos usar un punto aquí porque los comentarios de bloque pueden continuar en una nueva línea y los puntos no coinciden con el carácter de nueva-línea.</p>
<p><a class=p_ident id="p_mxzz/dlHK7" href="#p_mxzz/dlHK7"></a>Pero la salida del ejemplo anterior parece funcionar mal. ¿Por qué?</p>
<p><a class=p_ident id="p_G9NaQiyu/D" href="#p_G9NaQiyu/D"></a>La parte <code>_[^]*_</code> de la expresión, tal como describí en la sección de retroceso, se ajustará primero tanto como pueda. Si esto hace que la siguiente parte del patrón falle, el <em>matcher</em> retrocede un carácter e intenta de nuevo desde allí. En el ejemplo, el primero busca coincidir con todo el resto de la cadena (<em>string</em>) y luego retrocede desde allí. Encontrará una instancia de <code>_*/_</code> después de volver cuatro caracteres y emparejar eso. Esto no es lo que queríamos: la intención era hacer coincidir un solo comentario, no ir hasta el final del código y encontrar el final del último comentario de bloque.</p>
<p><a class=p_ident id="p_QK/wCKKVCw" href="#p_QK/wCKKVCw"></a>Debido a este comportamiento, decimos que los operadores de repetición (<code>_+_</code>, <code>_*_</code>, <code>_?_</code>, y <code>_{}_</code>) son codiciosos, lo que significa que coinciden tanto como pueden y retroceden desde allí. Si lo combinas con un signo de interrogación (<code>_+?_</code>, <code>_*?_</code>, <code>_??_</code>, <code>_{}_</code>?), pierden su codicia y empiezan por coincidir lo menos posible, <em>matcheando</em> más sólo cuando el patrón restante no encaja en el <em>match</em> más pequeño.</p>
<p><a class=p_ident id="p_MUXpQzArez" href="#p_MUXpQzArez"></a>Y eso es exactamente lo que queremos en este caso. Al tener <code>_*_</code> coincidir con la menor extensión de caracteres que nos lleve a un <code>_*/_</code>, consumimos un comentario de bloque y nada más.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_BVwRi9KKaW" href="#c_BVwRi9KKaW"></a><span class="cm-keyword">function</span> <span class="cm-variable">stripComments</span>(<span class="cm-def">code</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable-2">code</span>.<span class="cm-property">replace</span>(<span class="cm-string-2">/\/\/.*|\/\*[^]*?\*\//g</span>, <span class="cm-string">""</span>);
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">stripComments</span>(<span class="cm-string">"1 /* a */+/* b */ 1"</span>));
<span class="cm-comment">// → 1 + 1</span>

</pre>
<p>Una gran cantidad de errores en los programas de expresiones regulares se puede remontar a involuntariamente usando un operador de codiciosos, donde uno no codicioso funcionaría mejor. Cuando se utiliza un operador de repetición, considere la variante no codicioso primero.</p>

<h2>Dinámicamente la creación de objetos RegExp</h2>

<p>Hay casos en los que usted puede no saber el patrón exacto que necesita para que coincida en contra cuando se escribe el código. Digamos que quiere buscar el nombre del usuario en un trozo de texto y encerrarlo en caracteres de subrayado para hacer que se destaque. Ya que va a conocer el nombre de una sola vez el programa se está ejecutando, no se puede utilizar la notación basada en la barra.</p>
<p>En ese caso, se puede utilizar una <code>string</code> y usar el constructor <code>RegExp</code>. He aquí un ejemplo:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_P/kkkfGkoX" href="#c_P/kkkfGkoX"></a><span class="cm-keyword">var</span> <span class="cm-variable">name</span> <span class="cm-operator">=</span> <span class="cm-string">"harry"</span>;
<span class="cm-keyword">var</span> <span class="cm-variable">text</span> <span class="cm-operator">=</span> <span class="cm-string">"Harry is a suspicious character."</span>;
<span class="cm-keyword">var</span> <span class="cm-variable">regexp</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">RegExp</span>(<span class="cm-string">"\\b("</span> <span class="cm-operator">+</span> <span class="cm-variable">name</span> <span class="cm-operator">+</span> <span class="cm-string">")\\b"</span>, <span class="cm-string">"gi"</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">text</span>.<span class="cm-property">replace</span>(<span class="cm-variable">regexp</span>, <span class="cm-string">"_$1_"</span>));
<span class="cm-comment">// → _Harry_ is a suspicious character.</span></pre>



<p>Al indicar los límites <code>\b</code>, tenemos que usar doble barra invertida porque estamos trabajando con un <code>string</code>, en vez de con una expresión regular. El segundo argumento del constructor <code>RegExp</code> contiene las opciones para la expresión, en este caso  <code>"gi"</code> para global y sin distinción entre mayúsculas y minúsculas </p>

<p>
¿Pero qué ocurre si el nombre es <code>"dea+hl[]rd"</code>, un nombre posible si nuestro usuario es un ((nerd)) adolescente? Esto daría lugar a una expresión regular absurda, que no coincidirá con el nombre del usuario.
</p>

<p>Para evitar esto, podemos agregar barras inversas antes de cualquier carácter en el que no confiamos. Agregar barras invertidas antes de caracteres alfabéticos es una mala idea porque cosas como <code>\b</code> y <code>\n</code> tienen un significado especial. Pero escapar de todo lo que no es alfanumérico o espacio en blanco es seguro.</p>

</pre>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_GzFvfl17S9" href="#c_GzFvfl17S9"></a><span class="cm-keyword">var</span> <span class="cm-variable">name</span> <span class="cm-operator">=</span> <span class="cm-string">"dea+hl[]rd"</span>;
<span class="cm-keyword">var</span> <span class="cm-variable">text</span> <span class="cm-operator">=</span> <span class="cm-string">"This dea+hl[]rd guy is super annoying."</span>;
<span class="cm-keyword">var</span> <span class="cm-variable">escaped</span> <span class="cm-operator">=</span> <span class="cm-variable">name</span>.<span class="cm-property">replace</span>(<span class="cm-string-2">/[^\w\s]/g</span>, <span class="cm-string">"\\$&amp;"</span>);
<span class="cm-keyword">var</span> <span class="cm-variable">regexp</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">RegExp</span>(<span class="cm-string">"\\b("</span> <span class="cm-operator">+</span> <span class="cm-variable">escaped</span> <span class="cm-operator">+</span> <span class="cm-string">")\\b"</span>, <span class="cm-string">"gi"</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">text</span>.<span class="cm-property">replace</span>(<span class="cm-variable">regexp</span>, <span class="cm-string">"_$1_"</span>));
<span class="cm-comment">// → This _dea+hl[]rd_ guy is super annoying.</span></pre>

<h2>El método search</h2>
<p>El método <code>indexOf</code> de cadenas no se puede llamar desde una expresión regular. Pero hay otro método, <code>search</code>, que se puede invocar en una expresión regular. Al igual que <code>indexOf</code>, devuelve el primer índice en el que se encontró la expresión o devolverá <code>-1</code> si no encontró nada.</p>

<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_fi8qjwGs44" href="#c_fi8qjwGs44"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"  word"</span>.<span class="cm-property">search</span>(<span class="cm-string-2">/\S/</span>));
<span class="cm-comment">// → 2</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"    "</span>.<span class="cm-property">search</span>(<span class="cm-string-2">/\S/</span>));
<span class="cm-comment">// → -1</span></pre>

<p>Desafortunadamente, no hay manera de indicar que el <em>matcheo</em> comience en un determinado indice (como si podemos hacerlo con el segundo argumento en <code>indexOf</code>).</p>

<h2>La propiedad lastIndex</h2> 

<p>El método <code>exec</code> tampoco proporciona una manera comoda de iniciar una búsqueda desde una posición dada en la cadena, pero al menos si proporciona una manera incómoda de hacerlo.</p>

<p>Los objetos de expresión regular tienen propiedades. Una de estas propiedades es <code>source</code>, que contiene la cadena original de la que se creó la expresión. Otra propiedad es <code>lastIndex</code>, que controla, solo en algunas circunstancias, donde se iniciará la próxima partida.</p>

<p>Esas circunstancias son que la expresión regular debe tener activada la opción global (<code>g</code>), y la coincidencia debe pasar a través del método <code>exec</code>. Una vez más, una solución más lógica habría sido simplemente permitir que un argumento extra fuera pasado a <code>exec</code>, pero la cordura no es una característica de la interfaz de expresión regular de JavaScript.</p>

<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_7FwJtU2E26" href="#c_7FwJtU2E26"></a><span class="cm-keyword">var</span> <span class="cm-variable">pattern</span> <span class="cm-operator">=</span> <span class="cm-string-2">/y/g</span>;
<span class="cm-variable">pattern</span>.<span class="cm-property">lastIndex</span> <span class="cm-operator">=</span> <span class="cm-number">3</span>;
<span class="cm-keyword">var</span> <span class="cm-variable">match</span> <span class="cm-operator">=</span> <span class="cm-variable">pattern</span>.<span class="cm-property">exec</span>(<span class="cm-string">"xyzzy"</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">match</span>.<span class="cm-property">index</span>);
<span class="cm-comment">// → 4</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">pattern</span>.<span class="cm-property">lastIndex</span>);
<span class="cm-comment">// → 5</span></pre>

<p>Si el resultado fue satisfactorio, la llamada a <code>exec</code> actualiza automáticamente la propiedad <code>lastIndex</code> para apuntar después de la coincidencia. Si no se encontró ninguna coincidencia, <code>lastIndex</code> se pone de nuevo a cero, que es también el valor que tiene en un objeto de expresión regular de nueva construcción.</p>

<p>Cuando se utiliza un valor de expresión regular global para varias llamadas <code>exec</code>, estas actualizaciones automáticas a la propiedad <code>lastIndex</code> pueden causar problemas. Su expresión regular podría iniciarse accidentalmente en un índice que quedó de una llamada anterior.</p>

<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_11gVF/3Pva" href="#c_11gVF/3Pva"></a><span class="cm-keyword">var</span> <span class="cm-variable">digit</span> <span class="cm-operator">=</span> <span class="cm-string-2">/\d/g</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">digit</span>.<span class="cm-property">exec</span>(<span class="cm-string">"here it is: 1"</span>));
<span class="cm-comment">// → ["1"]</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">digit</span>.<span class="cm-property">exec</span>(<span class="cm-string">"and now: 1"</span>));
<span class="cm-comment">// → null</span></pre>



<p>Otro efecto interesante de la opción global es que cambia la forma en que funciona el método de coincidencia en cadenas (<code>match</code>). Cuando se llama con una expresión global, en lugar de devolver una matriz similar a la devuelta por <code>exec</code>, <code>match</code> encontrará todas las coincidencias del patrón en la cadena y devuelve una matriz que contiene las cadenas coincidentes.</p>

<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_9QAmqAqiUu" href="#c_9QAmqAqiUu"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Banana"</span>.<span class="cm-property">match</span>(<span class="cm-string-2">/an/g</span>));
<span class="cm-comment">// → ["an", "an"]</span></pre>
  
 <p> Así que tenga cuidado con las expresiones regulares globales. Los casos en los que son necesarios (las llamadas a
   <code>replace</code> y los lugares donde se desea utilizar explícitamente <code>lastIndex</code>) suelen ser los únicos lugares donde debería utilizarlos.</p>

<h2>Bucle de matchs</h2>

<p>Un patrón común es escanear todas las instancias de un patrón en una cadena, de forma que nos da acceso al objeto de coincidencia en el cuerpo del bucle, usando <code>lastIndex</code> y <code>exec</code>.</p>

<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_rOhT0RpnbZ" href="#c_rOhT0RpnbZ"></a><span class="cm-keyword">var</span> <span class="cm-variable">input</span> <span class="cm-operator">=</span> <span class="cm-string">"Una cadena con 3 números en su interior ... 42 y 88"</span>;
<span class="cm-keyword">var</span> <span class="cm-variable">number</span> <span class="cm-operator">=</span> <span class="cm-string-2">/\b(\d+)\b/g</span>;
<span class="cm-keyword">var</span> <span class="cm-variable">match</span>;
<span class="cm-keyword">while</span> (<span class="cm-variable">match</span> <span class="cm-operator">=</span> <span class="cm-variable">number</span>.<span class="cm-property">exec</span>(<span class="cm-variable">input</span>))
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Encontrado"</span>, <span class="cm-variable">match</span>[<span class="cm-number">1</span>], <span class="cm-string">"en"</span>, <span class="cm-variable">match</span>.<span class="cm-property">index</span>);
<span class="cm-comment">// → Encontrado 3 en 15</span>
<span class="cm-comment">//   Encontrado 42 en 44</span>
<span class="cm-comment">//   Encontrado 88 en 49</span></pre>


<p>Esto hace uso del hecho de que el valor de una expresión de asignación (<code> = </code>) es el valor asignado. Por lo tanto, utilizando <code>match = number.exec(input)</code> como condición en la sentencia <code>while</code>, realizamos la coincidencia al comienzo de cada iteración, guardamos su resultado en una variable y detenemos el bucle cuando no se encuentran más coincidencias.</p>

<h2>Análisis de un archivo INI</h2>

<p> Para concluir el capítulo, veremos un problema que requiere expresiones regulares. Imagina que estamos escribiendo un programa para recolectar automáticamente información sobre nuestros enemigos desde Internet. (En realidad, no escribiremos ese programa aquí, solo la parte que lee el archivo de configuración. Sentimos decepcionarlo.) El archivo de configuración se verá así:</p>

<pre data-language="text/plain" class="snippet cm-s-default"><a class="c_ident" id="c_OXIK3oNw6Q" href="#c_OXIK3oNw6Q"></a>searchengine=http://www.google.com/search?q=$1
spitefulness=9.7

; Los comentarios están precedidos por un punto y coma ...
; Cada sección se refiere a un enemigo individual
[larry]
fullname=Larry Doe
type=kindergarten bully
website=http://www.geocities.com/CapeCanaveral/11451

[gargamel]
fullname=Gargamel
type=evil sorcerer
outputdir=/home/marijn/enemies/gargamel</pre>

<p>Las reglas exactas para este formato (que en realidad es un formato ampliamente utilizado, generalmente llamado archivo INI) son las siguientes:</p>
<div class="ulist">
  <ul>
    <li>Las líneas en blanco y líneas que comienzan con punto y coma son ignoradas.</li>
   <li>Líneas envueltas en llaves <code>[ ]</code> inician una nueva sección.</li>
   <li>Las líneas que contienen un identificador alfanumérico seguido de un carácter = añaden una configuración a la sección actual.</li>
   <li>Cualquier otra cosa es inválida.</li>
</ul>
</div>
<p>
Nuestra tarea es convertir una cadena como ésta en una matriz de objetos, cada uno con una propiedad <code>name</code> y una matriz de configuraciones. Necesitaremos un objeto para cada sección y otro para la configuración global en la parte superior.
</p>
<p>Dado que el formato tiene que ser procesado línea por línea, dividir el archivo en líneas separadas es un buen comienzo. No obstante, algunos sistemas operativos utilizan no sólo un carácter de nueva línea para separar líneas, sino un carácter de retorno de carro seguido de una nueva línea (<code>"\r\n"</code>). Dado que el método <code>split</code> también permite que una expresión regular sea su argumento, podemos dividir en una expresión regular como <code>/\r?\n/</code> para dividir de una manera que permita tanto <code>"\n"</code> como <code>"\r\n"</code> entre líneas.</p>

<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_4pk9fouX3a" href="#c_4pk9fouX3a"></a><span class="cm-keyword">function</span> <span class="cm-variable">parseINI</span>(<span class="cm-def">string</span>) {
  <span class="cm-comment">// Cree el objeto en primer nivel</span>
  <span class="cm-keyword">var</span> <span class="cm-def">currentSection</span> <span class="cm-operator">=</span> {<span class="cm-property">name</span>: <span class="cm-atom">null</span>, <span class="cm-property">fields</span>: []};
  <span class="cm-keyword">var</span> <span class="cm-def">categories</span> <span class="cm-operator">=</span> [<span class="cm-variable-2">currentSection</span>];

  <span class="cm-variable-2">string</span>.<span class="cm-property">split</span>(<span class="cm-string-2">/\r?\n/</span>).<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">line</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">match</span>;
    <span class="cm-keyword">if</span> (<span class="cm-string-2">/^\s*(;.*)?$/</span>.<span class="cm-property">test</span>(<span class="cm-variable-2">line</span>)) {
      <span class="cm-keyword">return</span>;
    } <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">match</span> <span class="cm-operator">=</span> <span class="cm-variable-2">line</span>.<span class="cm-property">match</span>(<span class="cm-string-2">/^\[(.*)\]$/</span>)) {
      <span class="cm-variable-2">currentSection</span> <span class="cm-operator">=</span> {<span class="cm-property">name</span>: <span class="cm-variable-2">match</span>[<span class="cm-number">1</span>], <span class="cm-property">fields</span>: []};
      <span class="cm-variable-2">categories</span>.<span class="cm-property">push</span>(<span class="cm-variable-2">currentSection</span>);
    } <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">match</span> <span class="cm-operator">=</span> <span class="cm-variable-2">line</span>.<span class="cm-property">match</span>(<span class="cm-string-2">/^(\w+)=(.*)$/</span>)) {
      <span class="cm-variable-2">currentSection</span>.<span class="cm-property">fields</span>.<span class="cm-property">push</span>({<span class="cm-property">name</span>: <span class="cm-variable-2">match</span>[<span class="cm-number">1</span>],
                                  <span class="cm-property">value</span>: <span class="cm-variable-2">match</span>[<span class="cm-number">2</span>]});
    } <span class="cm-keyword">else</span> {
      <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">Error</span>(<span class="cm-string">"Line '"</span> <span class="cm-operator">+</span> <span class="cm-variable-2">line</span> <span class="cm-operator">+</span> <span class="cm-string">"' is invalid."</span>);
    }
  });

  <span class="cm-keyword">return</span> <span class="cm-variable-2">categories</span>;
}</pre>

</div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>  return categories;
}</pre>
</div></div>
<p>Este código pasa por todas las líneas del archivo, actualizando el objeto "_currentSection_" a medida que avanza. En primer lugar, comprueba si la línea se puede ignorar, utilizando la expresión <code>/^\s*(;.*)?$/</code>. ¿Ves cómo funciona? La parte entre los paréntesis coincidirá con los comentarios, y el signo <code>?</code> se asegurará de que también coincida con las líneas que contienen sólo espacios en blanco.</p>
<p>
Cuando la línea no es un comentario, el código comprueba si la línea inicia una nueva sección. Si es así, crea un nuevo objeto de sección actual, al que se añadirán los ajustes siguientes.</p>
<p>
La última posibilidad significativa es que la línea es un ajuste normal, por lo que nuestro código lo agregará al objeto de sección actual.</p>

<p>Si una línea no coincide con ninguno de estos formularios, la función produce un error.</p>
<p>Tenga en cuenta el uso recurrente de <code>^</code> y <code>$</code> para asegurarse de que la expresión coincide con toda la línea, no sólo parte de ella. Dejando estos resultados en código que funciona sobre todo, pero se comporta extrañamente para algunos tipos de _input_, lo que puede originar un error difícil de rastrear.</p>
<p>El patrón <code>if (match = string.match(...))</code> es similar al truco de usar una asignación como condición para <code>while</code>. A menudo no estaremos seguros de que nuestra llamada al matchear tendrá éxito, por lo que se puede acceder al objeto resultante sólo dentro de una instrucción if que las pruebas de ello. Para no romper la agradable cadena que forma la sentencia <code>if</code>, asignamos el resultado de la coincidencia a una variable e inmediatamente utilizamos esa asignación como el test en la sentencia <code>if</code>.
</p>

<h2>Caracteres internacionales</h2> 

<p>Debido a la implementación simplista inicial de JavaScript y al hecho de que este enfoque se estableció como base del comportamiento estándar, las expresiones regulares de JavaScript son bastante torpes acerca de los caracteres que no aparecen en el idioma inglés. Por ejemplo, en lo que se refiere a las expresiones regulares de JavaScript, un "carácter de texto"  es sólo uno de los 26 caracteres del alfabeto latino (mayúsculas o minúsculas) y, por alguna razón, el carácter underscore (_). Caracteres como <em>é</em> o <em>β</em>, que definitivamente son caracteres de texto, no coincidirán con <code>\w</code>` (y coincidirán con  <code>\W</code>, carácter para no texto).</p>

<p>Por un extraño accidente histórico, <code>\s</code> (espacio en blanco) no tiene este problema y coincide con todos los caracteres que el estándar _Unicode_ considera espacios en blanco, incluyendo cosas como el espacio no separable y el separador de vocales mongol.</p>

<p>Algunas implementaciones de expresiones regulares en otros lenguajes de programación tienen sintaxis para coincidir con categorías de caracteres Unicode específicas, como "todas las letras mayúsculas", "todos los signos de puntuación" o "caracteres de control". Hay planes para agregar soporte para JavaScript de estas categorías, pero por desgracia parece que no en un futuro próximo.</p>

<h2 id="summary_regexp">Resumen</h2> 
<p>
Las expresiones regulares son objetos que representan patrones en cadenas. Utilizan su propia sintaxis para expresar estos patrones.
</p>


<table>
<tbody><tr>
<td><code>/abc/</code></td>
<td>Una secuencia de caracteres</td>
</tr>
<tr>
<td><code>/[abc]/</code></td>
<td>Cualquier carácter en un conjunto de caracteres</td>
</tr>
<tr>
<td><code>/[^abc]/</code></td>
<td>Cualquier carácter que <em>no</em> este en un conjunto de caracteres</td>
</tr>
<tr>
<td><code>/[0-9]/</code></td>
<td>Cualquier carácter en un rango de caracteres</td>
</tr>
<tr>
<td><code>/x+/</code></td>
<td>Una o más ocurrencias del patrón <code>x</code></td>
</tr>
<tr>
<td><code>/x+?/</code></td>
<td>Una o mas ocurrencias, no codiciosos</td>
</tr>
<tr>
<td><code>/x*/</code></td>
<td>Cero o mas ocurrencias</td>
</tr>
<tr>
<td><code>/x?/</code></td>
<td>Cero o una ocurrencia</td>
</tr>
<tr>
<td><code>/x{2,4}/</code></td>
<td>Entre dos o cuatro ocurrencias</td>
</tr>
<tr>
<td><code>/(abc)/</code></td>
<td>Un grupo</td>
</tr>
<tr>
<td><code>/a|b|c/</code></td>
<td>Cualqiera de estos patrones</td>
</tr>
<tr>
<td><code>/\d/</code></td>
<td>Cualquier carácter digital</td>
</tr>
<tr>
<td><code>/\w/</code></td>
<td>Cualquier carácter alfanúmerico (“word character”)</td>
</tr>
<tr>
<td><code>/\s/</code></td>
<td>Cualquier carácter de espacio en blanco</td>
</tr>
<tr>
<td><code>/./</code></td>
<td>Cualquier carácter excepto nuevas líneas</td>
</tr>
<tr>
<td><code>/\b/</code></td>
<td>Limite de palabra</td>
</tr>
<tr>
<td><code>/^/</code></td>
<td>Inicio de la entrada</td>
</tr>
<tr>
<td><code>/$/</code></td>
<td>Fin de entrada</td>
</tr>
</tbody></table>

<p>Una expresión regular tiene un método <code>test</code> para comprobar si una cadena dada tiene coincidencias con ella. También tiene un método <code>exec</code> que, cuando se encuentra una coincidencia, devuelve una matriz que contiene todos los grupos coincidentes. Dicha matriz tiene una propiedad de índice (<code>index</code>) que indica dónde se inició la coincidencia.</p>

<p>Las cadenas tienen un método <code>match</code> para buscar coincidencia con una expresión regular y un método <code>search</code> para realizar busquedas, que devuelve sólo la posición inicial de la coincidencia. El método <code>replace</code>  puede reemplazar las coincidencias (los _matcheos_) de un patrón con una cadena de reemplazo. Como alternativa puedes crear una función <code>replace</code>,  y así crear una cadena de reemplazo basada en el texto de coincidencia y los grupos coincidentes.</p>

<p>Las expresiones regulares pueden tener opciones, que se escriben después de la barra de cierre (_/_). La opción <code>i</code> hace que el matcheo sea insensible a mayusculas y minusculas (case insensitive), mientras que la opción <code>g</code> hace que la expresión sea global, eso genera, entre otras cosas, hace que el método <code>replace</code> reemplace todas las instancias en lugar de sólo la primera.</p>

<p>El constructor <code>RegExp</code> se puede utilizar para crear un valor de expresión regular a partir de una cadena.</p>

<p>Las expresiones regulares son una herramienta muy afilada con un comando torpe. Ello simplifican algunas tareas pero pueden volverse incontrolables cuando se aplican a problemas complejos. Parte de saber cómo usarlos es resistir el impulso de intentar utilizarlas en los casos incorrectos.</p>


<h2> Ejercicios </h2>

<p>Es casi inevitable que cuando haga estos ejercicios, se confunda y se frustre por el comportamiento inexplicable de alguna expresión regular. A veces, ayuda a introducir su expresión en una herramienta en línea como <a href="https://www.debuggex.com/">debuggex.com</a> para ver si su solución corresponde con lo que usted buscaba y experimentar con la forma en que ésta responde a distintas cadenas.</p>

<h3> Regexp golf </h3>

<p>
<em>Code golf</em> es un término usado en un juego que busca expresar un programa determinado en la mínima cantidad de caracteres posible. Del mismo modo, _regexp golf_ es la práctica de escribir una expresión regular tan pequeña como sea posible para que coincida con un patrón dado, y sólo ese patrón.</p>

<p>Para cada uno de los siguientes elementos, escriba una expresión regular que compruebe si alguna de las subcadenas se produce en una cadena. La expresión regular debe coincidir sólo con cadenas que contengan una de las subcadenas descritas. No se preocupe por los límites de palabras a menos que se mencionen explícitamente. Cuando logre que su expresión funcione, vea si puede lograr reducir la expresión.</p>

<ol>
    <li><em>car</em> and <em>cat</em></li>
    <li><em>pop</em> and <em>prop</em></li>
    <li><em>ferret</em>, <em>ferry</em>, y <em>ferrari</em></li>
    <li>Cualquier palabra que termine en <em>ious</em></li>
    <li> carácter de espacio en blanco seguido de un punto, coma, dos puntos o punto y coma</li>
    <li> Una palabra de más de seis letras</li>
    <li>Una palabra sin la letra <em>e</em></li>
</ol>

<p>Consulte la tabla del <a href="09_regexp.html#summary_regexp">[resumen del capítulo]</a> para obtener ayuda. Pruebe cada solución con unas cuantas cadenas de prueba.</p>

<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_PjFdBrmWuQ" href="#c_PjFdBrmWuQ"></a><span class="cm-comment">// Fill in the regular expressions</span>

<span class="cm-variable">verify</span>(<span class="cm-string-2">/.../</span>,
       [<span class="cm-string">"my car"</span>, <span class="cm-string">"bad cats"</span>],
       [<span class="cm-string">"camper"</span>, <span class="cm-string">"high art"</span>]);

<span class="cm-variable">verify</span>(<span class="cm-string-2">/.../</span>,
       [<span class="cm-string">"pop culture"</span>, <span class="cm-string">"mad props"</span>],
       [<span class="cm-string">"plop"</span>]);

<span class="cm-variable">verify</span>(<span class="cm-string-2">/.../</span>,
       [<span class="cm-string">"ferret"</span>, <span class="cm-string">"ferry"</span>, <span class="cm-string">"ferrari"</span>],
       [<span class="cm-string">"ferrum"</span>, <span class="cm-string">"transfer A"</span>]);

<span class="cm-variable">verify</span>(<span class="cm-string-2">/.../</span>,
       [<span class="cm-string">"how delicious"</span>, <span class="cm-string">"spacious room"</span>],
       [<span class="cm-string">"ruinous"</span>, <span class="cm-string">"consciousness"</span>]);

<span class="cm-variable">verify</span>(<span class="cm-string-2">/.../</span>,
       [<span class="cm-string">"bad punctuation ."</span>],
       [<span class="cm-string">"escape the dot"</span>]);

<span class="cm-variable">verify</span>(<span class="cm-string-2">/.../</span>,
       [<span class="cm-string">"hottentottententen"</span>],
       [<span class="cm-string">"no"</span>, <span class="cm-string">"hotten totten tenten"</span>]);

<span class="cm-variable">verify</span>(<span class="cm-string-2">/.../</span>,
       [<span class="cm-string">"red platypus"</span>, <span class="cm-string">"wobbling nest"</span>],
       [<span class="cm-string">"earth bed"</span>, <span class="cm-string">"learning ape"</span>]);


<span class="cm-keyword">function</span> <span class="cm-variable">verify</span>(<span class="cm-def">regexp</span>, <span class="cm-def">yes</span>, <span class="cm-def">no</span>) {
  <span class="cm-comment">// Ignore unfinished exercises</span>
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">regexp</span>.<span class="cm-property">source</span> <span class="cm-operator">==</span> <span class="cm-string">"..."</span>) <span class="cm-keyword">return</span>;
  <span class="cm-variable-2">yes</span>.<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">s</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable-2">regexp</span>.<span class="cm-property">test</span>(<span class="cm-variable-2">s</span>))
      <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Failure to match '"</span> <span class="cm-operator">+</span> <span class="cm-variable-2">s</span> <span class="cm-operator">+</span> <span class="cm-string">"'"</span>);
  });
  <span class="cm-variable-2">no</span>.<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">s</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">regexp</span>.<span class="cm-property">test</span>(<span class="cm-variable-2">s</span>))
      <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Unexpected match for '"</span> <span class="cm-operator">+</span> <span class="cm-variable-2">s</span> <span class="cm-operator">+</span> <span class="cm-string">"'"</span>);
  });
}</pre>

<h3>Estilo de citas</h3> 

<p>Imagine que ha escrito una historia en Ingles y ha usado comillas simples para marcar partes del diálogo. Ahora desea reemplazar todas las citas de diálogo con comillas dobles, manteniendo las comillas simples que se usan en contracciones.</p>

<p>Piense en un patrón que distinga estos dos tipos de comillado y cree una llamada al método <code>replace</code> que haga la sustitución adecuada.</p>

<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_XWzNC0bK4D" href="#c_XWzNC0bK4D"></a><span class="cm-keyword">var</span> <span class="cm-variable">text</span> <span class="cm-operator">=</span> <span class="cm-string">"'I'm the cook,' he said, 'it's my job.'"</span>;
<span class="cm-comment">// Change this call.</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">text</span>.<span class="cm-property">replace</span>(<span class="cm-string-2">/A/g</span>, <span class="cm-string">"B"</span>));
<span class="cm-comment">// → "I'm the cook," he said, "it's my job."</span></pre>


<div class="solution">
  <div class="solution-text">


    </div>
</div>

<p>La solución más obvia es reemplazar las citas con un carácter sin palabras al menos en uno de los lados. Algo como <code>/\W'|'\W/</code>, pero también tenga en cuenta el principio y el final de cada línea.</p>
<p>Además, debe asegurarse de que el reemplazo también incluya los caracteres que coincidan con el patrón <code>\W</code> para que no se eliminen. Esto se puede hacer envolviéndolos entre paréntesis e incluyendo sus grupos en la cadena de reemplazo (<code>$1</code>, <code>$2</code>). Los grupos que no coincidan serán reemplazados por nada.</p>


<h3>Números de nuevo</h3>

<p>Una serie de dígitos puede ser igualada por la expresión regular simple <code>/\d+/</code>.</p>

<p>Escriba una expresión que coincida sólo con los números válidos para JavaScript. Debe soportar un signo positivo o negativo adicional delante del número, el punto decimal y la notación de exponente --<code>5e-3</code> o <code>1E10</code>-- tambien con la opcion de un signo delante del exponente. Observe también que no es necesario que haya dígitos delante o después del punto, pero el número no puede ser solamente un punto, es decir, <code>.5</code> y <code>5.</code> son números JavaScript válidos, pero un punto solitario no lo es.</p>


<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_svZIRqtX/7" href="#c_svZIRqtX/7"></a><span class="cm-comment">// Fill in this regular expression.</span>
<span class="cm-keyword">var</span> <span class="cm-variable">number</span> <span class="cm-operator">=</span> <span class="cm-string-2">/^...$/</span>;

<span class="cm-comment">// Tests:</span>
[<span class="cm-string">"1"</span>, <span class="cm-string">"-1"</span>, <span class="cm-string">"+15"</span>, <span class="cm-string">"1.55"</span>, <span class="cm-string">".5"</span>, <span class="cm-string">"5."</span>, <span class="cm-string">"1.3e2"</span>, <span class="cm-string">"1E-4"</span>,
 <span class="cm-string">"1e+12"</span>].<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">s</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable">number</span>.<span class="cm-property">test</span>(<span class="cm-variable-2">s</span>))
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Failed to match '"</span> <span class="cm-operator">+</span> <span class="cm-variable-2">s</span> <span class="cm-operator">+</span> <span class="cm-string">"'"</span>);
});
[<span class="cm-string">"1a"</span>, <span class="cm-string">"+-1"</span>, <span class="cm-string">"1.2.3"</span>, <span class="cm-string">"1+1"</span>, <span class="cm-string">"1e4.5"</span>, <span class="cm-string">".5."</span>, <span class="cm-string">"1f5"</span>,
 <span class="cm-string">"."</span>].<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">s</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable">number</span>.<span class="cm-property">test</span>(<span class="cm-variable-2">s</span>))
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Incorrectly accepted '"</span> <span class="cm-operator">+</span> <span class="cm-variable-2">s</span> <span class="cm-operator">+</span> <span class="cm-string">"'"</span>);
});</pre>

<div class="solution">
  <div class="solution-text">
<p>En primer lugar, no se olvide de la barra invertida delante del punto.</p>

<p>Se puede hacer coincidir el signo opcional delante del número, así como delante del exponente, con <code>[+\-]?</code> o <code>(\+|-|)</code> (más, menos o nada).</p>
<p>La parte más complicada del ejercicio es el problema de coincidir con <code>"5."</code> y <code>".5"</code> sin igualar también <code>"."</code> . Para ello, una buena solución es utilizar el operador <code>|</code> para separar los dos casos: uno o más dígitos opcionalmente seguido por un punto y cero o más dígitos o un punto seguido por uno o más dígitos.</p>

<p>Por último, para que en el caso del carácter <em>e</em> no distinga entre mayúsculas y minúsculas, agregue una opción <code>i</code> a la expresión regular o utilice <code>[eE]</code>.</p>
  </div>
</div>


<nav>
  <a href="08_error.html" title="capítulo previo">◀</a>
  <a href="index.html" title="cover">◆</a>
  <a href="10_modules.html" title="capítulo siguiente">▶</a>
</nav>
</article>

