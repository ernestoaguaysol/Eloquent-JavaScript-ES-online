<!doctype html>
<head>
  <meta charset="utf-8">
  <title>Bugs y manejo de errores :: Eloquent JavaScript</title>
  <link rel=stylesheet href="js/node_modules/codemirror/lib/codemirror.css">
  <script src="js/acorn_codemirror.js"></script>
  <link rel=stylesheet href="css/ejs.css">
  <script src="js/sandbox.js"></script>
  <script src="js/ejs.js"></script>
  <script>var chapNum = 8;var sandboxLoadFiles = ["code/chapter/08_error.js"];</script>
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-53624335-3', 'auto');
  ga('send', 'pageview');

  </script>
</head>

<article>
<nav>
  <a href="07_elife.html" title="capítulo previo">◀</a>
  <a href="index.html" title="cover">◆</a>
  <a href="09_regexp.html" title="capítulo siguiente">▶</a>
</nav>

<h1><div class=chap_num>Capítulo 8</div>Bugs y manejo de errores</h1>
<blockquote>
<p><a class=p_ident id="p_B5WKjmJcN+" href="#p_B5WKjmJcN+"></a>La depuración es dos veces más difícil que escribir código. Por lo tanto, si usted escribe su código lo mejor que puede, por definición, usted no es lo suficientemente inteligente como para depurar lo que escribió.</p>
 <footer>Brian Kernighan and P.J. Plauger, <cite>The Elements of Programming Style</cite></footer>
</blockquote>
<blockquote>
<p><a class=p_ident id="p_VboTZeolEF" href="#p_VboTZeolEF"></a>Yuan-Ma había escrito un pequeño programa que usaba muchas variables globales y atajos de mala calidad. Al leerlo, un estudiante le preguntó: 'Nos advirtió contra estas técnicas, sin embargo usted las usa en su programa. ¿Cómo puede ser? "El maestro respondió:" No hay necesidad de buscar una manguera de agua si la casa no está en llamas ".</p>
 <footer>Master Yuan-Ma, <cite>The Book of Programming</cite></footer>
</blockquote>
<p><a class=p_ident id="p_cxajp67y54" href="#p_cxajp67y54"></a>Un programa es un pensamiento cristalizado. A veces son pensamientos con errores, otras veces  los errores se producen al convertir nuestros pensamientos en código. De cualquier manera, el resultado es un programa defectuoso.</p>
<p><a class=p_ident id="p_X+u/rE+ZQP" href="#p_X+u/rE+ZQP"></a>Las fallas en un programa se llaman generalmente <em>bugs</em>. Los <em>bugs</em> pueden ser errores de programación o problemas en otros sistemas con los que nuestro programa interactúa. Algunos son inmediatamente evidentes, mientras que otros son sutiles y pueden permanecer ocultos en un sistema durante años.</p>
<p><a class=p_ident id="p_CONhPRKs1r" href="#p_CONhPRKs1r"></a>A menudo, los problemas solamente surgen cuando un programa encuentra una situación que el programador no consideró originalmente. A veces tales situaciones son inevitables. Cuando se le pide al usuario que ingrese su edad (“<em>your age_”) y este tipea naranja (_“orange”</em>), esto pone a nuestro programa a prueba. Está situación tiene que ser anticipada y manejada de alguna manera.</p>
<h2><a class=h_ident id="h_T//hB2SSRf" href="#h_T//hB2SSRf"></a>Errores de programación</h2>
<p><a class=p_ident id="p_J6zpZDVk9E" href="#p_J6zpZDVk9E"></a>Cuando se trata de errores del programador, nuestro tarea es simple: encontrarlos y arreglarlos. Tales errores pueden ir desde simples errores de tipeo, que causan que la computadora nos avice tan pronto como pone los ojos en nuestro programa, a errores sutiles a nuestra comprensión de la forma en que el programa opera, causando resultados incorrectos sólo en situaciones específicas. Los errores de este último tipo pueden tomar semanas para manifestarse.</p>
<p><a class=p_ident id="p_bSd++I4Guk" href="#p_bSd++I4Guk"></a>El grado en que los lenguajes le ayudan a encontrar tales errores varía. No es sorprendente que JavaScript esté en el extremo de apenas ayuda de esa escala. Algunos lenguajes quieren saber los tipos de todas sus variables y expresiones antes incluso de ejecutar un programa y le dirán de inmediato cuando un tipo se utiliza de una manera inconsistente. JavaScript considera los tipos sólo cuando realmente ejecuta el programa, e incluso entonces, le permite hacer algunas cosas claramente absurdas sin quejarse, como <em>x = true * "monkey"</em>.</p>
<p><a class=p_ident id="p_/62UQU9iAK" href="#p_/62UQU9iAK"></a>Sí hay algunas cosas que JavaScript no permite hacer. Escribir un programa que no es sintácticamente válido inmediatamente provocará un error. Otras cosas, como llamar a algo que no es una función o buscar una propiedad en un valor indefinido, provocará que se informe un error cuando el programa se está ejecutando y encuentra dicha acción sin sentido.</p>
<p><a class=p_ident id="p_f8JBpfO0rx" href="#p_f8JBpfO0rx"></a>Pero muchas veces, un cálculo sin sentido simplemente producirá un <em>NaN</em> (no un número) o <em>undefined</em> (valor indefinido). Y el programa continúa feliz, convencido de que está haciendo algo significativo. El error se manifestará sólo más tarde, después de que el valor falso haya recorrido varias funciones. No desencadena un error, pero en silencio hace que el resultado del programa sea incorrecto. Encontrar la fuente de tales problemas puede ser difícil.</p>
<p><a class=p_ident id="p_oKWHqdp8XU" href="#p_oKWHqdp8XU"></a>El proceso de encontrar errores (<em>bugs</em>) en los programas se llama depuración (<em>debugging</em>).</p>
<h2><a class=h_ident id="h_wDxHe8+q/c" href="#h_wDxHe8+q/c"></a>Modo estricto (<em>Strict mode</em>)</h2>
<p><a class=p_ident id="p_FrEfOLT6fj" href="#p_FrEfOLT6fj"></a>JavaScript se puede hacer un poco más estricto al permitir el modo estricto. Esto se hace poniendo la cadena "<em>use strict</em>" en la parte superior de un archivo o en el cuerpo de función. He aquí un ejemplo:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_FcQI1yk8Zc" href="#c_FcQI1yk8Zc"></a><span class="cm-keyword">function</span> <span class="cm-variable">canYouSpotTheProblem</span>() {
  <span class="cm-string">"use strict"</span>;
  <span class="cm-keyword">for</span> (<span class="cm-variable">counter</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable">counter</span> <span class="cm-operator">&lt;</span> <span class="cm-number">10</span>; <span class="cm-variable">counter</span><span class="cm-operator">++</span>)
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Happy happy"</span>);
}

<span class="cm-variable">canYouSpotTheProblem</span>();
<span class="cm-comment">// → ReferenceError: counter is not defined</span></pre>
<p><a class=p_ident id="p_2rb+ic3uHl" href="#p_2rb+ic3uHl"></a>Normalmente, cuando te olvidas de poner <em>var</em> delante de tu variable, como <em>counter</em> en el ejemplo, JavaScript crea una variable global en silencio y usa eso. En el modo estricto, sin embargo, un error se informa en su lugar. Esto es muy útil. Debe tenerse en cuenta, sin embargo, que esto no funciona cuando la variable en cuestión ya existe como global, sólo funciona cuando no existe y la asignación que hemos hecho la habría creado.</p>
<p><a class=p_ident id="p_lfaDZgw0a8" href="#p_lfaDZgw0a8"></a>Otro cambio en modo estricto es que <em>this</em> mantiene el valor <em>undefined</em> en funciones que no se llaman como métodos. Al hacer una llamada fuera del modo estricto, <em>this</em> se refiere al objeto de alcance global. Así que si accidentalmente llama a un método o constructor incorrectamente en modo estricto, JavaScript producirá un error tan pronto como intente leer algo de esto, en lugar de trabajar felizmente con el objeto global, crear y leer variables globales.</p>
<p><a class=p_ident id="p_LnCLiHifSu" href="#p_LnCLiHifSu"></a>Por ejemplo, considere el siguiente código, que llama a un <em>constructor</em> sin la palabra clave <em>new</em>, de modo que <em>this</em> no se refiere al objeto recien construído:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_2P6r0kQUC7" href="#c_2P6r0kQUC7"></a><span class="cm-keyword">function</span> <span class="cm-variable">Person</span>(<span class="cm-def">name</span>) { <span class="cm-keyword">this</span>.<span class="cm-property">name</span> <span class="cm-operator">=</span> <span class="cm-variable-2">name</span>; }
<span class="cm-keyword">var</span> <span class="cm-variable">ferdinand</span> <span class="cm-operator">=</span> <span class="cm-variable">Person</span>(<span class="cm-string">"Ferdinand"</span>); <span class="cm-comment">// oops</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">name</span>);
<span class="cm-comment">// → Ferdinand</span></pre>
<p><a class=p_ident id="p_ZaxvGLctob" href="#p_ZaxvGLctob"></a>Así que la llamada falsa a <em>Person</em> tuvo éxito pero devolvió un valor <em>undefined</em> y creó el nombre de la variable en forma global. En modo estricto, el resultado es diferente.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_/mrlkOkUQM" href="#c_/mrlkOkUQM"></a><span class="cm-string">"use strict"</span>;
<span class="cm-keyword">function</span> <span class="cm-variable">Person</span>(<span class="cm-def">name</span>) { <span class="cm-keyword">this</span>.<span class="cm-property">name</span> <span class="cm-operator">=</span> <span class="cm-variable-2">name</span>; }
<span class="cm-comment">// Oops, forgot 'new'</span>
<span class="cm-keyword">var</span> <span class="cm-variable">ferdinand</span> <span class="cm-operator">=</span> <span class="cm-variable">Person</span>(<span class="cm-string">"Ferdinand"</span>);
<span class="cm-comment">// → TypeError: Cannot set property 'name' of undefined</span></pre>
<p><a class=p_ident id="p_weXHyZ2RJN" href="#p_weXHyZ2RJN"></a>Nos dice inmediatamente que algo está mal. Esto es muy útil.</p>
<p><a class=p_ident id="p_R6rUgXg6qF" href="#p_R6rUgXg6qF"></a>El modo estricto (<em>Strict mode</em>) hace algunas cosas más: Se prohíbe dar a una función múltiples parámetros con el mismo nombre y elimina completamente ciertas características problemáticas del lenguaje (como la declaración <em>which</em>, que es tan equivocada que no volveré a mencionarla en este libro).</p>
<p><a class=p_ident id="p_HpBvidetBo" href="#p_HpBvidetBo"></a>En pocas palabras, poner un <em>use strict</em> en la parte superior de su programa rara vez causa daño y puede ayudarle a detectar un problema.</p>
<h2><a class=h_ident id="h_Of3sEZTZQh" href="#h_Of3sEZTZQh"></a><em>Tests</em></h2>
<p><a class=p_ident id="p_Mh0wNpH7/y" href="#p_Mh0wNpH7/y"></a>Si el lenguaje no va a hacer mucho para ayudarnos a encontrar errores, tendremos que encontrarlos de la manera más difícil: ejecutando el programa y ver si hace lo correcto.</p>
<p><a class=p_ident id="p_WuQPcKl4aJ" href="#p_WuQPcKl4aJ"></a>Hacer esto a mano, una y otra vez, es una manera segura de volverse loco. Afortunadamente, a menudo es posible escribir un segundo programa que automatice las pruebas de su programa.</p>
<p><a class=p_ident id="p_wLLkaGY2Py" href="#p_wLLkaGY2Py"></a>Como ejemplo, volvemos a utilizar el tipo <em>Vector</em>.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_mciWzOsKpc" href="#c_mciWzOsKpc"></a><span class="cm-keyword">function</span> <span class="cm-variable">Vector</span>(<span class="cm-def">x</span>, <span class="cm-def">y</span>) {
  <span class="cm-keyword">this</span>.<span class="cm-property">x</span> <span class="cm-operator">=</span> <span class="cm-variable-2">x</span>;
  <span class="cm-keyword">this</span>.<span class="cm-property">y</span> <span class="cm-operator">=</span> <span class="cm-variable-2">y</span>;
}
<span class="cm-variable">Vector</span>.<span class="cm-property">prototype</span>.<span class="cm-property">plus</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">other</span>) {
  <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">Vector</span>(<span class="cm-keyword">this</span>.<span class="cm-property">x</span> <span class="cm-operator">+</span> <span class="cm-variable-2">other</span>.<span class="cm-property">x</span>, <span class="cm-keyword">this</span>.<span class="cm-property">y</span> <span class="cm-operator">+</span> <span class="cm-variable-2">other</span>.<span class="cm-property">y</span>);
};</pre>
<p><a class=p_ident id="p_e3B//aHoQV" href="#p_e3B//aHoQV"></a>Escribiremos un programa para comprobar que nuestra implementación de <em>Vector</em> funciona como se pretende. Luego, cada vez que cambiamos la implementación, seguimos ejecutando el programa de prueba para que podamos estar razonablemente seguros de que no rompimos nada. Cuando agregamos funcionalidad adicional (por ejemplo, un nuevo método) al tipo <em>Vector</em>, también agregamos pruebas para la nueva característica.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_RdZhkUBFh0" href="#c_RdZhkUBFh0"></a><span class="cm-keyword">function</span> <span class="cm-variable">testVector</span>() {
  <span class="cm-keyword">var</span> <span class="cm-def">p1</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Vector</span>(<span class="cm-number">10</span>, <span class="cm-number">20</span>);
  <span class="cm-keyword">var</span> <span class="cm-def">p2</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Vector</span>(<span class="cm-operator">-</span><span class="cm-number">10</span>, <span class="cm-number">5</span>);
  <span class="cm-keyword">var</span> <span class="cm-def">p3</span> <span class="cm-operator">=</span> <span class="cm-variable-2">p1</span>.<span class="cm-property">plus</span>(<span class="cm-variable-2">p2</span>);

  <span class="cm-keyword">if</span> (<span class="cm-variable-2">p1</span>.<span class="cm-property">x</span> <span class="cm-operator">!==</span> <span class="cm-number">10</span>) <span class="cm-keyword">return</span> <span class="cm-string">"fail: x property"</span>;
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">p1</span>.<span class="cm-property">y</span> <span class="cm-operator">!==</span> <span class="cm-number">20</span>) <span class="cm-keyword">return</span> <span class="cm-string">"fail: y property"</span>;
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">p2</span>.<span class="cm-property">x</span> <span class="cm-operator">!==</span> <span class="cm-operator">-</span><span class="cm-number">10</span>) <span class="cm-keyword">return</span> <span class="cm-string">"fail: negative x property"</span>;
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">p3</span>.<span class="cm-property">x</span> <span class="cm-operator">!==</span> <span class="cm-number">0</span>) <span class="cm-keyword">return</span> <span class="cm-string">"fail: x from plus"</span>;
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">p3</span>.<span class="cm-property">y</span> <span class="cm-operator">!==</span> <span class="cm-number">25</span>) <span class="cm-keyword">return</span> <span class="cm-string">"fail: y from plus"</span>;
  <span class="cm-keyword">return</span> <span class="cm-string">"everything ok"</span>;
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">testVector</span>());
<span class="cm-comment">// → everything ok</span></pre>
<p><a class=p_ident id="p_orgidb9EzO" href="#p_orgidb9EzO"></a>Escribir pruebas como ésta tiende a producir código bastante repetitivo, incómodo. Afortunadamente, existen piezas de software que ayudan a crear y ejecutar conjuntos de pruebas (<em>test suites</em>) proporcionando un lenguaje (en forma de funciones y métodos) adecuado para expresar las pruebas y para emitir información puntual cuando una prueba falla. Estos se llaman <em>testing frameworks</em>.</p>
<h2><a class=h_ident id="h_iVsnyIAWUT" href="#h_iVsnyIAWUT"></a><em>Debugging</em></h2>
<p><a class=p_ident id="p_Wg8h9d/mPj" href="#p_Wg8h9d/mPj"></a>Una vez que usted nota que hay algo mal con su programa porque se comporta mal o produce errores, el siguiente paso es averiguar cuál es el problema.</p>
<p><a class=p_ident id="p_AuzxnqBdGR" href="#p_AuzxnqBdGR"></a>A veces es obvio. El mensaje de error apuntará en una línea específica de su programa y si observa la descripción del error y esa línea de código, a menudo puede ver el problema.</p>
<p><a class=p_ident id="p_QtE4UNknE2" href="#p_QtE4UNknE2"></a>Pero no siempre. A veces la línea que desencadenó el problema es simplemente el primer lugar donde se utiliza de manera no válida un valor erroneo que fue producido en otro lugar. Y a veces no hay ningún mensaje de error en absoluto, sólo un resultado no válido. Si ha estado resolviendo los ejercicios en los capítulos anteriores, es probable que ya haya experimentado tales situaciones.</p>
<p><a class=p_ident id="p_l8Sr8nvlo/" href="#p_l8Sr8nvlo/"></a>El programa de ejemplo siguiente intenta convertir un número entero en una cadena en cualquier base (decimal, binario, etc.) seleccionando repetidamente el último dígito y luego dividiendo el número para eliminar este dígito. Pero la valor de retorno ridículo que produce actualmente sugiere que tiene un error (<em>bug</em>).</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_jFkKTMxqUA" href="#c_jFkKTMxqUA"></a><span class="cm-keyword">function</span> <span class="cm-variable">numberToString</span>(<span class="cm-def">n</span>, <span class="cm-def">base</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">result</span> <span class="cm-operator">=</span> <span class="cm-string">""</span>, <span class="cm-def">sign</span> <span class="cm-operator">=</span> <span class="cm-string">""</span>;
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">n</span> <span class="cm-operator">&lt;</span> <span class="cm-number">0</span>) {
    <span class="cm-variable-2">sign</span> <span class="cm-operator">=</span> <span class="cm-string">"-"</span>;
    <span class="cm-variable-2">n</span> <span class="cm-operator">=</span> <span class="cm-operator">-</span><span class="cm-variable-2">n</span>;
  }
  <span class="cm-keyword">do</span> {
    <span class="cm-variable-2">result</span> <span class="cm-operator">=</span> <span class="cm-variable">String</span>(<span class="cm-variable-2">n</span> <span class="cm-operator">%</span> <span class="cm-variable-2">base</span>) <span class="cm-operator">+</span> <span class="cm-variable-2">result</span>;
    <span class="cm-variable-2">n</span> <span class="cm-operator">/=</span> <span class="cm-variable-2">base</span>;
  } <span class="cm-keyword">while</span> (<span class="cm-variable-2">n</span> <span class="cm-operator">></span> <span class="cm-number">0</span>);
  <span class="cm-keyword">return</span> <span class="cm-variable-2">sign</span> <span class="cm-operator">+</span> <span class="cm-variable-2">result</span>;
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">numberToString</span>(<span class="cm-number">13</span>, <span class="cm-number">10</span>));
<span class="cm-comment">// → 1.5e-3231.3e-3221.3e-3211.3e-3201.3e-3191.3e-3181.3…</span></pre>
<p><a class=p_ident id="p_9XnRU6TMyw" href="#p_9XnRU6TMyw"></a>Incluso si usted ya noto cual es el problema, finja por un momento que aun no lo a descubierto. Sabemos que nuestro programa está funcionando mal, y queremos averiguar por qué.</p>
<p><a class=p_ident id="p_hLdoEaFqQ1" href="#p_hLdoEaFqQ1"></a>Aquí es donde debe resistir el impulso de comenzar a hacer cambios aleatorios en el código. Trate de analizar lo que está sucediendo y llegar a una teoría de por qué podría estar sucediendo. Luego, haga observaciones adicionales para probar esta teoría o, si aún no tiene una teoría, haga observaciones adicionales que podrían ayudarle a encontrar una.</p>
<p><a class=p_ident id="p_sRBhYIBhU2" href="#p_sRBhYIBhU2"></a>Poner unas pocas llamadas <em>console.log</em> estratégicas en el programa es una buena manera de obtener información adicional sobre lo que está haciendo el programa. En este caso, queremos que <em>n</em> tome los valores <em>13</em>, <em>1</em> y luego <em>0</em>. Vamos a escribir su valor al inicio del bucle.</p>
<pre>13
1.3
0.13
0.013
…
1.5e-323</pre>
<p><a class=p_ident id="p_c630rm4nFA" href="#p_c630rm4nFA"></a><em>Right</em>. Dividir <em>13</em> por <em>10</em> no produce un número entero. En lugar de <em>n / = base</em>, lo que realmente queremos es <em>n = Math.floor (n / base)</em> para que el número se desplace correctamente a la derecha.</p>
<p><a class=p_ident id="p_Y/82YA+zTF" href="#p_Y/82YA+zTF"></a>Una alternativa al uso de <em>console.log</em> es utilizar las capacidades de depuración de su navegador. Los navegadores modernos vienen con la capacidad de establecer un punto de interrupción en una línea específica de su código. Esto hará que la ejecución del programa se detenga cada vez que se alcanza la línea con el punto de interrupción y le permite inspeccionar los valores de las variables en ese punto. No entraré en detalles aquí ya que los depuradores difieren de navegador a navegador, pero busque en las herramientas de desarrollo de su navegador y busque en la Web más información. Otra forma de establecer un punto de interrupción es incluir una declaración de depurador (que consiste simplemente en la palabra clave <em>debugger</em>) en su programa. Si las herramientas de desarrollo de su navegador están activas, el programa se detendrá cada vez que llegue a esa declaración, y podrá inspeccionar su estado.</p>
<h2><a class=h_ident id="h_a0SXG/vlkA" href="#h_a0SXG/vlkA"></a>Propagación de errores</h2>
<p><a class=p_ident id="p_Mwrlw/tieA" href="#p_Mwrlw/tieA"></a>No todos los problemas pueden ser prevenidos por el programador. Si su programa se comunica con el mundo exterior de alguna manera, existe la posibilidad de que la entrada que obtenga sea inválida o que otros sistemas con los que intente hablar estén rotos o inaccesibles.</p>
<p><a class=p_ident id="p_mJMmXRQgTa" href="#p_mJMmXRQgTa"></a>Los programas sencillos, o programas que se ejecutan sólo bajo su supervisión, pueden permitirse el lujo de dejar de funcionar cuando se produce un problema de este tipo. Examinarás el problema y lo intentarás de nuevo. Pero las aplicaciones "reales" no se pueden simplemente desconectar. A veces lo correcto es tomar la entrada mala y seguir corriendo. En otros casos, es mejor informar al usuario de lo que salió mal y luego desconectar. Pero en cualquier situación, el programa tiene que hacer algo activamente en respuesta al problema.</p>
<p><a class=p_ident id="p_MxYQB/IwXb" href="#p_MxYQB/IwXb"></a>Digamos que tiene una función <em>promptInteger</em> que pide al usuario un número entero y lo devuelve.
Pero ¿Qué debe devolver si el usuario ingresa una palabra, por ejemplo confunde "<em>your age</em>" por “_orange_”?</p>
<p><a class=p_ident id="p_HYlrhHIEpN" href="#p_HYlrhHIEpN"></a>Una opción es hacer que devuelva un valor especial. Las opciones comunes para estos valores son <em>null</em> y no <em>undefined</em>.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_bwVY9M+AHx" href="#c_bwVY9M+AHx"></a><span class="cm-keyword">function</span> <span class="cm-variable">promptNumber</span>(<span class="cm-def">question</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">result</span> <span class="cm-operator">=</span> <span class="cm-variable">Number</span>(<span class="cm-variable">prompt</span>(<span class="cm-variable-2">question</span>, <span class="cm-string">""</span>));
  <span class="cm-keyword">if</span> (<span class="cm-variable">isNaN</span>(<span class="cm-variable-2">result</span>)) <span class="cm-keyword">return</span> <span class="cm-atom">null</span>;
  <span class="cm-keyword">else</span> <span class="cm-keyword">return</span> <span class="cm-variable-2">result</span>;
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">promptNumber</span>(<span class="cm-string">"How many trees do you see?"</span>));</pre>
<p><a class=p_ident id="p_LA+1rAESib" href="#p_LA+1rAESib"></a>Esta es una buena estrategia. Ahora cualquier código que llama a <em>promptNumber</em> debe comprobar si se ha leído un número real y, de no ser así, debe reiniciar el proceso de alguna manera, tal vez preguntando de nuevo o rellenando con un valor predeterminado. O podría devolver un valor especial a su llamador (<em>caller</em>) para indicar que no pudo hacer lo que se le pidió.</p>
<p><a class=p_ident id="p_p7J7sL+IrG" href="#p_p7J7sL+IrG"></a>En muchas situaciones, sobre todo cuando los errores son comunes y el metodo <em>caller</em> debe tenerlo explícitamente en cuenta, devolver un valor especial es una manera prolija de indicar un error. Sin embargo, tiene sus desventajas. Primero, ¿qué pasa si la función ya puede devolver todo tipo posible de valores? Para esta función, es difícil encontrar un valor especial que pueda distinguirse de un resultado válido.</p>
<p><a class=p_ident id="p_RkPtPeA8yC" href="#p_RkPtPeA8yC"></a>La segunda cuestión con la devolución de valores especiales es que puede conducir a algún código muy abarrotado. Si un pedazo de código llama a <em>promptNumber</em> 10 veces, tiene que comprobar 10 veces si se devolvió <em>null</em>. Y si su respuesta a encontrar <em>null</em> es simplemente devolver <em>null</em> a sí mismo, el llamador (<em>caller</em>) a su vez tendrá que comprobarlo, y así sucesivamente.</p>
<h2><a class=h_ident id="h_6MskLb8+Lo" href="#h_6MskLb8+Lo"></a>Excepciones</h2>
<p><a class=p_ident id="p_8kL59rmzNL" href="#p_8kL59rmzNL"></a>Cuando una función no puede proceder normalmente, lo que nos gustaría hacer es simplemente detener lo que estamos haciendo y trabajar en un contexto donde sabemos cómo manejar el problema. Esto es el “manejo de excepciones”.</p>
<p><a class=p_ident id="p_E5sj1+GyhK" href="#p_E5sj1+GyhK"></a>Las excepciones (<em>exceptions</em>) son un mecanismo que hace posible que el código que se ejecuta en un problema lance (<em>throw</em>) una excepción, que es simplemente lanzar un valor. Elevar una excepción se asemeja en cierta medida a un retorno súper cargado de una función: se eleva no sólo de la función actual, sino también de sus llamantes, hasta la primera llamada que inició la ejecución actual. Esto se llama desenrollar la pila (<em>unwinding the stack</em>). Recuerde el concepto de “pila de llamadas de función” en el <a href="03_functions.html#stack">Capítulo 3</a>. Una excepción reduce el zoom de esta pila, eliminando todos los contextos de llamada que encuentra.</p>
<p><a class=p_ident id="p_xcw2n6B9Pa" href="#p_xcw2n6B9Pa"></a>Si las excepciones siempre estan cerca de la parte inferior de la pila, no serían de mucha utilidad, pues sólo proporcionaría una nueva manera de lanzar su programa. Su poder reside en el hecho de que usted puede establecer "obstáculos" a lo largo de la pila para capturar la excepción. Entonces usted puede actuar, después de que el programa continúa funcionando en el punto donde registró la excepción.</p>
<p><a class=p_ident id="p_WKg+Dzz+NH" href="#p_WKg+Dzz+NH"></a>He aquí un ejemplo:</p>
<pre id="look" data-language="javascript" class="snippet cm-s-default"><span class="cm-keyword">function</span> <span class="cm-variable">promptDirection</span>(<span class="cm-def">question</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">result</span> <span class="cm-operator">=</span> <span class="cm-variable">prompt</span>(<span class="cm-variable-2">question</span>, <span class="cm-string">""</span>);
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">result</span>.<span class="cm-property">toLowerCase</span>() <span class="cm-operator">==</span> <span class="cm-string">"left"</span>) <span class="cm-keyword">return</span> <span class="cm-string">"L"</span>;
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">result</span>.<span class="cm-property">toLowerCase</span>() <span class="cm-operator">==</span> <span class="cm-string">"right"</span>) <span class="cm-keyword">return</span> <span class="cm-string">"R"</span>;
  <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">Error</span>(<span class="cm-string">"Invalid direction: "</span> <span class="cm-operator">+</span> <span class="cm-variable-2">result</span>);
}

<span class="cm-keyword">function</span> <span class="cm-variable">look</span>() {
  <span class="cm-keyword">if</span> (<span class="cm-variable">promptDirection</span>(<span class="cm-string">"Which way?"</span>) <span class="cm-operator">==</span> <span class="cm-string">"L"</span>)
    <span class="cm-keyword">return</span> <span class="cm-string">"a house"</span>;
  <span class="cm-keyword">else</span>
    <span class="cm-keyword">return</span> <span class="cm-string">"two angry bears"</span>;
}

<span class="cm-keyword">try</span> {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"You see"</span>, <span class="cm-variable">look</span>());
} <span class="cm-keyword">catch</span> (<span class="cm-def">error</span>) {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Something went wrong: "</span> <span class="cm-operator">+</span> <span class="cm-variable-2">error</span>);
}</pre>
<p><a class=p_ident id="p_z6N2aOWPzg" href="#p_z6N2aOWPzg"></a>La palabra clave <em>throw</em> se utiliza para generar una excepción. Capturar una se hace envolviendo (<em>wrapping</em>) un pedazo de código en un bloque <em>try</em>, seguido por la palabra clave <em>catch</em>. Cuando el código del bloque <em>try</em> genera una excepción, se evalúa el bloque <em>catch</em>. El nombre de la variable (entre paréntesis) después de la captura se enlazará al valor de la excepción. Una vez finalizado el bloqueo del bloque (o si el bloque <em>try</em> termina sin problemas), el control se desarrolla debajo de toda la sentencia <em>try</em>/<em>catch</em>.</p>
<p><a class=p_ident id="p_c0Zz+Cs1iJ" href="#p_c0Zz+Cs1iJ"></a>En este caso, utilizamos el constructor <em>Error</em> para crear nuestro valor de excepción  (<em>new Error</em>). . Se trata de un constructor de JavaScript estándar que crea un objeto con una propiedad de mensaje. En los entornos de JavaScript modernos, las instancias de este constructor también recopilan información sobre la pila de llamadas que existía cuando se creó la excepción, un denominado seguimiento de la pila (<em>stack trace</em>). Esta información se almacena en la propiedad de la pila y puede ser útil al intentar depurar un problema: nos indica la función exacta donde ocurrió el problema y cuáles otras funciones llevaron a la llamada que falló.</p>
<p><a class=p_ident id="p_xm9YMspJUy" href="#p_xm9YMspJUy"></a>Tenga en cuenta que en nuestro ejemplo la función <em>look</em> ignora por completo la posibilidad de que <em>promptDirection</em> pueda salir mal. Esta es la gran ventaja de las excepciones: el código de manejo de errores sólo es necesario en el punto donde se produce el error y en el punto donde se maneja. Las funciones intermedias pueden desentenderse de todo.
Bueno, casi...</p>
<h2><a class=h_ident id="h_vMqO7D2Z+H" href="#h_vMqO7D2Z+H"></a>Limpieza después de excepciones</h2>
<p><a class=p_ident id="p_SuFGGKD2/O" href="#p_SuFGGKD2/O"></a>Considere la siguiente situación: una función, <em>withContext</em>, quiere asegurarse de que, durante su ejecución, la variable de nivel superior <em>context</em> contiene un valor específico. Después de que termina, restaura esta variable a su valor anterior.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_FkbwqXEJ6U" href="#c_FkbwqXEJ6U"></a><span class="cm-keyword">var</span> <span class="cm-variable">context</span> <span class="cm-operator">=</span> <span class="cm-atom">null</span>;

<span class="cm-keyword">function</span> <span class="cm-variable">withContext</span>(<span class="cm-def">newContext</span>, <span class="cm-def">body</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">oldContext</span> <span class="cm-operator">=</span> <span class="cm-variable">context</span>;
  <span class="cm-variable">context</span> <span class="cm-operator">=</span> <span class="cm-variable-2">newContext</span>;
  <span class="cm-keyword">var</span> <span class="cm-def">result</span> <span class="cm-operator">=</span> <span class="cm-variable-2">body</span>();
  <span class="cm-variable">context</span> <span class="cm-operator">=</span> <span class="cm-variable-2">oldContext</span>;
  <span class="cm-keyword">return</span> <span class="cm-variable-2">result</span>;
}</pre>
<p><a class=p_ident id="p_2B4CALF551" href="#p_2B4CALF551"></a>¿Qué pasa si <em>body</em> plantea una excepción? En ese caso, la llamada a <em>withContext</em> será eliminada de la pila por la excepción, y <em>context</em> nunca volverá a su valor anterior.</p>
<p><a class=p_ident id="p_kQr0z0blXP" href="#p_kQr0z0blXP"></a>Hay una característica más que tiene <em>try</em>. Puede ser seguida por un bloque <em>finally</em> en lugar de, o además de, un bloque <em>catch</em>. Un bloque <em>finally</em> dice "No importa lo que pase, ejecute este código después de intentar ejecutar el código en el bloque <em>try</em>". Si una función tiene que limpiar algo, el código de limpieza normalmente se debe poner en el bloque <em>finally</em>.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_1Nrg8ROQ4a" href="#c_1Nrg8ROQ4a"></a><span class="cm-keyword">function</span> <span class="cm-variable">withContext</span>(<span class="cm-def">newContext</span>, <span class="cm-def">body</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">oldContext</span> <span class="cm-operator">=</span> <span class="cm-variable">context</span>;
  <span class="cm-variable">context</span> <span class="cm-operator">=</span> <span class="cm-variable-2">newContext</span>;
  <span class="cm-keyword">try</span> {
    <span class="cm-keyword">return</span> <span class="cm-variable-2">body</span>();
  } <span class="cm-keyword">finally</span> {
    <span class="cm-variable">context</span> <span class="cm-operator">=</span> <span class="cm-variable-2">oldContext</span>;
  }
}</pre>
<p><a class=p_ident id="p_fPrMEVAuIx" href="#p_fPrMEVAuIx"></a>Tenga en cuenta que ya no tenemos que almacenar el resultado del <em>body</em> (que queremos devolver) en una variable. Incluso si regresamos directamente desde el bloque <em>try</em>, se ejecutará el bloque <em>finally</em>. Podemos hacerlo y estar seguros:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_+Ix6z74g0L" href="#c_+Ix6z74g0L"></a><span class="cm-keyword">try</span> {
  <span class="cm-variable">withContext</span>(<span class="cm-number">5</span>, <span class="cm-keyword">function</span>() {
    <span class="cm-keyword">if</span> (<span class="cm-variable">context</span> <span class="cm-operator">&lt;</span> <span class="cm-number">10</span>)
      <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">Error</span>(<span class="cm-string">"Not enough context!"</span>);
  });
} <span class="cm-keyword">catch</span> (<span class="cm-def">e</span>) {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Ignoring: "</span> <span class="cm-operator">+</span> <span class="cm-variable-2">e</span>);
}
<span class="cm-comment">// → Ignoring: Error: Not enough context!</span>

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">context</span>);
<span class="cm-comment">// → null</span></pre>
<p><a class=p_ident id="p_Tp+h3u87BQ" href="#p_Tp+h3u87BQ"></a>A pesar de que la función llamada por withContext explotó, en <em>withContext</em> se limpió adecuadamente la variable <em>context</em>.</p>
<h2><a class=h_ident id="h_vfoJqEDazI" href="#h_vfoJqEDazI"></a>Selective catching</h2>
<p><a class=p_ident id="p_7OzeVs5deG" href="#p_7OzeVs5deG"></a>Cuando una excepción hace todo el camino a la parte inferior de la pila sin ser capturada, se maneja por el medio ambiente. Lo que esto significa difiere entre entornos. En los navegadores, normalmente se escribe una descripción del error en la consola de JavaScript (accesible a través del menú Herramientas o Desarrollador del navegador).</p>
<p><a class=p_ident id="p_gLdJYSuXJP" href="#p_gLdJYSuXJP"></a>Para los errores o problemas del programador que el programa no puede manejar, simplemente dejar pasar el error es lo correcto a menudo. Una excepción no tratada es una forma razonable de señalar un programa roto, y la consola de JavaScript, en navegadores modernos, le proporcionará cierta información sobre qué llamadas de función estaban en la pila cuando ocurrió el problema.</p>
<p><a class=p_ident id="p_8ikIirRkv1" href="#p_8ikIirRkv1"></a>Para los problemas que se espera que sucedan durante el uso rutinario, estrellarse con una excepción no tratada no es una respuesta amigable.</p>
<p><a class=p_ident id="p_qoUMB3TCui" href="#p_qoUMB3TCui"></a>Los usos no válidos del lenguaje, como hacer referencia a una variable inexistente, buscar una propiedad en <em>null</em> o llamar a algo que no es una función, también darán lugar a que se generen excepciones. Tales excepciones se pueden capturar igual que sus propias excepciones.</p>
<p><a class=p_ident id="p_zdqzGGSAD9" href="#p_zdqzGGSAD9"></a>Cuando se introduce un <em>catch</em>, todo lo que sabemos es que algo en nuestro <em>try</em> causó una excepción. Pero no sabemos qué, ni qué excepción causó.</p>
<p><a class=p_ident id="p_f3440ZNnkm" href="#p_f3440ZNnkm"></a>JavaScript (en una omisión bastante flagrante) no proporciona soporte directo para capturar selectivamente las excepciones: o bien las captura todas o no las captura. Esto hace que sea muy fácil asumir que la excepción que se obtiene es la misma que la que se estaba pensando cuando escribió el bloque <em>catch</em>.</p>
<p><a class=p_ident id="p_69/Cvwa1V5" href="#p_69/Cvwa1V5"></a>Pero puede que no lo sea. Es posible que se haya violado alguna otra suposición o que haya introducido un error en algún lugar que esté causando una excepción. He aquí un ejemplo, que intenta seguir llamando a <em>promptDirection</em> hasta obtener una respuesta válida:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_kiCmEf4A8f" href="#c_kiCmEf4A8f"></a><span class="cm-keyword">for</span> (;;) {
  <span class="cm-keyword">try</span> {
    <span class="cm-keyword">var</span> <span class="cm-variable">dir</span> <span class="cm-operator">=</span> <span class="cm-variable">promtDirection</span>(<span class="cm-string">"Where?"</span>); <span class="cm-comment">// ← typo!</span>
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"You chose "</span>, <span class="cm-variable">dir</span>);
    <span class="cm-keyword">break</span>;
  } <span class="cm-keyword">catch</span> (<span class="cm-def">e</span>) {
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Not a valid direction. Try again."</span>);
  }
}</pre>
<p><a class=p_ident id="p_IIG0iDYHoq" href="#p_IIG0iDYHoq"></a>El constructo <em>for (;;)</em> es una forma de crear intencionalmente un bucle que no termina por sí solo. Salimos del bucle sólo cuando se da una dirección válida. Pero hemos escrito erróneamente promptDirection, lo que resultará en un error de "variable indefinida". Debido a que el bloque de <em>catch</em> ignora completamente su valor de excepción (<em>e</em>), suponiendo que sabe cuál es el problema, trata erróneamente el error de variable como indicativo de entrada incorrecta. Esto no sólo causa un bucle infinito, sino que también "entierra" el útil mensaje de error sobre la variable mal escrita.</p>
<p><a class=p_ident id="p_GVphouYQ5a" href="#p_GVphouYQ5a"></a>AComo regla general, no cubra las excepciones de captura a menos que sea con el propósito de "enrutarlas" en alguna parte, por ejemplo, a través de la red para decirle a otro sistema que nuestro programa se ha estrellado. E incluso entonces, piense cuidadosamente en cómo podría estar ocultando información.</p>
<p><a class=p_ident id="p_rVC6Mkv7+Y" href="#p_rVC6Mkv7+Y"></a>Así que queremos capturar un tipo específico de excepción. Podemos hacer esto comprobando en el bloque <em>catch</em> si la excepción que conseguimos es la que buscamos y probar de otra manera. Pero, ¿cómo reconocemos una excepción?</p>
<p><a class=p_ident id="p_dgMpP89BN6" href="#p_dgMpP89BN6"></a>Por supuesto, podríamos igualar su propiedad de mensaje con el mensaje de error que esperamos. Pero esa es una manera inestable de escribir código: usariamos la información destinada al consumo humano (el mensaje) para tomar una decisión programática. Tan pronto como alguien cambia (o traduce) el mensaje, el código dejará de funcionar.</p>
<p><a class=p_ident id="p_LdvJV7l+4j" href="#p_LdvJV7l+4j"></a>Más bien, definamos un nuevo tipo de error y usamos <em>instanceof</em> para identificarlo.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_ZtibWk6KwK" href="#c_ZtibWk6KwK"></a><span class="cm-keyword">function</span> <span class="cm-variable">InputError</span>(<span class="cm-def">message</span>) {
  <span class="cm-keyword">this</span>.<span class="cm-property">message</span> <span class="cm-operator">=</span> <span class="cm-variable-2">message</span>;
  <span class="cm-keyword">this</span>.<span class="cm-property">stack</span> <span class="cm-operator">=</span> (<span class="cm-keyword">new</span> <span class="cm-variable">Error</span>()).<span class="cm-property">stack</span>;
}
<span class="cm-variable">InputError</span>.<span class="cm-property">prototype</span> <span class="cm-operator">=</span> <span class="cm-variable">Object</span>.<span class="cm-property">create</span>(<span class="cm-variable">Error</span>.<span class="cm-property">prototype</span>);
<span class="cm-variable">InputError</span>.<span class="cm-property">prototype</span>.<span class="cm-property">name</span> <span class="cm-operator">=</span> <span class="cm-string">"InputError"</span>;</pre>
<p><a class=p_ident id="p_DVlxwgAuKa" href="#p_DVlxwgAuKa"></a>El prototipo se crea al derivar de <em>Error.prototype</em> para que <em>instanceof Error</em> también devuelva <em>true</em> para los objetos <em>InputError</em>. También se le da una propiedad de nombre (<em>name</em>) ya que los tipos de error estándar (<em>Error</em>, <em>SyntaxError</em>, <em>ReferenceError</em>, etc.) también tienen dicha propiedad.</p>
<p><a class=p_ident id="p_6hiRXoB1pc" href="#p_6hiRXoB1pc"></a>La asignación a la propiedad <em>stack</em> intenta dar a este objeto un rastreo de pila algo útil (en plataformas que lo soportan) creando un objeto de error regular y luego utilizando la propiedad <em>stack</em> de ese objeto como propio.</p>
<p><a class=p_ident id="p_7b8OxrUjd6" href="#p_7b8OxrUjd6"></a>Ahora <em>promptDirection</em> puede lanzar tal error.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_sIDbifSyff" href="#c_sIDbifSyff"></a><span class="cm-keyword">function</span> <span class="cm-variable">promptDirection</span>(<span class="cm-def">question</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">result</span> <span class="cm-operator">=</span> <span class="cm-variable">prompt</span>(<span class="cm-variable-2">question</span>, <span class="cm-string">""</span>);
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">result</span>.<span class="cm-property">toLowerCase</span>() <span class="cm-operator">==</span> <span class="cm-string">"left"</span>) <span class="cm-keyword">return</span> <span class="cm-string">"L"</span>;
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">result</span>.<span class="cm-property">toLowerCase</span>() <span class="cm-operator">==</span> <span class="cm-string">"right"</span>) <span class="cm-keyword">return</span> <span class="cm-string">"R"</span>;
  <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">InputError</span>(<span class="cm-string">"Invalid direction: "</span> <span class="cm-operator">+</span> <span class="cm-variable-2">result</span>);
}</pre>
<p><a class=p_ident id="p_+Xi1noyKXN" href="#p_+Xi1noyKXN"></a>Y el bucle <em>for</em> puede atraparlo con más cuidado.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_tTVsZNAA73" href="#c_tTVsZNAA73"></a><span class="cm-keyword">for</span> (;;) {
  <span class="cm-keyword">try</span> {
    <span class="cm-keyword">var</span> <span class="cm-variable">dir</span> <span class="cm-operator">=</span> <span class="cm-variable">promptDirection</span>(<span class="cm-string">"Where?"</span>);
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"You chose "</span>, <span class="cm-variable">dir</span>);
    <span class="cm-keyword">break</span>;
  } <span class="cm-keyword">catch</span> (<span class="cm-def">e</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">e</span> <span class="cm-keyword">instanceof</span> <span class="cm-variable">InputError</span>)
      <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Not a valid direction. Try again."</span>);
    <span class="cm-keyword">else</span>
      <span class="cm-keyword">throw</span> <span class="cm-variable-2">e</span>;
  }
}</pre>
<p><a class=p_ident id="p_1KdxT7IkRO" href="#p_1KdxT7IkRO"></a>Esto captura sólo instancias de <em>InputError</em> y permite excepciones a través de <em>throw</em>. Si reintroduce el error de tipeo, el error de variable <em>undefined</em> se informará correctamente.</p>
<h2><a class=h_ident id="h_Sb9V3BEus1" href="#h_Sb9V3BEus1"></a>Assertions</h2>
<p><a class=p_ident id="p_t3qOx5E10C" href="#p_t3qOx5E10C"></a>Las afirmaciones son una herramienta para comprobar la salud básica de los errores de programación. Considere la función auxiliar <em>assert</em>:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_EMQnc6zgG7" href="#c_EMQnc6zgG7"></a><span class="cm-keyword">function</span> <span class="cm-variable">AssertionFailed</span>(<span class="cm-def">message</span>) {
  <span class="cm-keyword">this</span>.<span class="cm-property">message</span> <span class="cm-operator">=</span> <span class="cm-variable-2">message</span>;
}
<span class="cm-variable">AssertionFailed</span>.<span class="cm-property">prototype</span> <span class="cm-operator">=</span> <span class="cm-variable">Object</span>.<span class="cm-property">create</span>(<span class="cm-variable">Error</span>.<span class="cm-property">prototype</span>);

<span class="cm-keyword">function</span> <span class="cm-variable">assert</span>(<span class="cm-def">test</span>, <span class="cm-def">message</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable-2">test</span>)
    <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">AssertionFailed</span>(<span class="cm-variable-2">message</span>);
}

<span class="cm-keyword">function</span> <span class="cm-variable">lastElement</span>(<span class="cm-def">array</span>) {
  <span class="cm-variable">assert</span>(<span class="cm-variable-2">array</span>.<span class="cm-property">length</span> <span class="cm-operator">></span> <span class="cm-number">0</span>, <span class="cm-string">"empty array in lastElement"</span>);
  <span class="cm-keyword">return</span> <span class="cm-variable-2">array</span>[<span class="cm-variable-2">array</span>.<span class="cm-property">length</span> <span class="cm-operator">-</span> <span class="cm-number">1</span>];
}</pre>
<p><a class=p_ident id="p_JNUjlOsrDt" href="#p_JNUjlOsrDt"></a>Esto proporciona una manera compacta de cumplir las expectativas, ayudando a alertar del programa si la condición declarada no se cumple. Por ejemplo, la función <em>lastElement</em>, que recupera el último elemento de una matriz, retornaría indefinidamente arrays vacíos si la aserción (<em>assertion</em>) se omitiera. Obtener el último elemento de una matriz vacía no tiene mucho sentido, por lo que es casi seguro que es el resultado de un error de programador.</p>
<p><a class=p_ident id="p_8ZLXWCZN0m" href="#p_8ZLXWCZN0m"></a>Las afirmaciones (<em>Assertions</em>) son una manera de asegurarse de que los errores causan fallas en el punto del error, en lugar de producir silenciosamente valores sin sentido que pueden causar problemas en una parte no relacionada del sistema.</p>
<h2><a class=h_ident id="h_Ntq802iJIM" href="#h_Ntq802iJIM"></a>Resumén</h2>
<p><a class=p_ident id="p_Klqv1MQw91" href="#p_Klqv1MQw91"></a>Los errores y malas aportaciones son hechos de la vida. Los errores en los programas necesitan ser encontrados y arreglados. Pueden ser más fáciles de notar al tener suites de pruebas (<em>test suites</em>) automatizadas y añadir aserciones a sus programas.</p>
<p><a class=p_ident id="p_5h5RI4cLlT" href="#p_5h5RI4cLlT"></a>Los problemas causados por factores ajenos al control del programa normalmente deben manejarse con gracia. A veces, cuando el problema se puede manejar localmente, los valores de retorno especiales son una forma sana de rastrearlos. De lo contrario, las excepciones son preferibles.</p>
<p><a class=p_ident id="p_u9aRt0scbk" href="#p_u9aRt0scbk"></a>El lanzamiento de una excepción provoca que la pila de llamadas se desenrolle hasta el siguiente bloque de <em>try</em>/<em>catch</em> o hasta la parte inferior de la pila. El valor de excepción se dará al bloque de <em>catch</em> que lo captura, lo que debería comprobar que es realmente el tipo esperado de excepción y luego hacer algo con él. Para manejar el flujo de control impredecible causado por las excepciones, finalmente los bloques se pueden usar para asegurar que un pedazo de código siempre se ejecuta al finalizar un bloque.</p>
<h2><a class=h_ident id="h_tkm7ntLto1" href="#h_tkm7ntLto1"></a>Ejercicios</h2>
<h3><a class=h_ident id="h_n1zYouiAfX" href="#h_n1zYouiAfX"></a>Retry</h3>
<p><a class=p_ident id="p_pQpH28Gouc" href="#p_pQpH28Gouc"></a>Digamos que tiene una función primitiveMultiply que, en el 50 por ciento de los casos, multiplica dos números, y en el otro 50 por ciento, plantea una excepción del tipo MultiplicatorUnitFailure. Escribir una función que envuelva esta mala función y sigue intentandolo hasta que una llamada tenga éxito, después de lo cual devuelva el resultado.</p>
<p><a class=p_ident id="p_/suQSDbG4b" href="#p_/suQSDbG4b"></a>Asegúrese de manejar solo las excepciones que desea manejar.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_ni2m/X6n2e" href="#c_ni2m/X6n2e"></a><span class="cm-keyword">function</span> <span class="cm-variable">MultiplicatorUnitFailure</span>() {}

<span class="cm-keyword">function</span> <span class="cm-variable">primitiveMultiply</span>(<span class="cm-def">a</span>, <span class="cm-def">b</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable">Math</span>.<span class="cm-property">random</span>() <span class="cm-operator">&lt;</span> <span class="cm-number">0.5</span>)
    <span class="cm-keyword">return</span> <span class="cm-variable-2">a</span> <span class="cm-operator">*</span> <span class="cm-variable-2">b</span>;
  <span class="cm-keyword">else</span>
    <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">MultiplicatorUnitFailure</span>();
}

<span class="cm-keyword">function</span> <span class="cm-variable">reliableMultiply</span>(<span class="cm-def">a</span>, <span class="cm-def">b</span>) {
  <span class="cm-comment">// Your code here.</span>
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">reliableMultiply</span>(<span class="cm-number">8</span>, <span class="cm-number">8</span>));
<span class="cm-comment">// → 64</span></pre>
<div class=solution><div class=solution-text>
<p><a class=p_ident id="p_W/KGHRTCVv" href="#p_W/KGHRTCVv"></a>La llamada a <em>primitiveMultiply</em> obviamente ocurre en un bloque <em>try</em>. El bloque <em>catch</em> correspondiente debe volver a crear la excepción cuando no es una instancia de <em>MultiplicatorUnitFailure</em> y asegurarse de que la llamada se reintente cuando si lo es.</p>
<p><a class=p_ident id="p_YBwGY5ZSyG" href="#p_YBwGY5ZSyG"></a>Para hacer el reintento, puede utilizar un bucle que se rompe sólo cuando una llamada tiene éxito -como en el ejemplo de vista anterior en este capítulo- o recursión de uso (<em>use recursion</em>) y espero que no obtenga una cadena de errores tan larga que se desborda la pila (Lo qué seguro ocurrirá).</p>
</div></div>
<h3><a class=h_ident id="h_GIkxFIOlsn" href="#h_GIkxFIOlsn"></a>La caja cerrada</h3>
<p><a class=p_ident id="p_bU8PIMHh9W" href="#p_bU8PIMHh9W"></a>Considere el siguiente (y bastante artificial) objeto:
object:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_hjKamI1Ais" href="#c_hjKamI1Ais"></a><span class="cm-keyword">var</span> <span class="cm-variable">box</span> <span class="cm-operator">=</span> {
  <span class="cm-property">locked</span>: <span class="cm-atom">true</span>,
  <span class="cm-property">unlock</span>: <span class="cm-keyword">function</span>() { <span class="cm-keyword">this</span>.<span class="cm-property">locked</span> <span class="cm-operator">=</span> <span class="cm-atom">false</span>; },
  <span class="cm-property">lock</span>: <span class="cm-keyword">function</span>() { <span class="cm-keyword">this</span>.<span class="cm-property">locked</span> <span class="cm-operator">=</span> <span class="cm-atom">true</span>;  },
  <span class="cm-property">_content</span>: [],
  <span class="cm-property">get</span> <span class="cm-property">content</span>() {
    <span class="cm-keyword">if</span> (<span class="cm-keyword">this</span>.<span class="cm-property">locked</span>) <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">Error</span>(<span class="cm-string">"Locked!"</span>);
    <span class="cm-keyword">return</span> <span class="cm-keyword">this</span>.<span class="cm-property">cContent</span>;
  }
};</pre>
<p><a class=p_ident id="p_ym5HkJ1IMM" href="#p_ym5HkJ1IMM"></a>It is a box Es una caja con una cerradura. Dentro hay una matriz, pero sólo se puede obtener cuando se desbloquea la caja. No se permite acceder directamente a la propiedad <em>cContent</em>.</p>
<p><a class=p_ident id="p_WAzXNAp4c7" href="#p_WAzXNAp4c7"></a>Escriba una función llamada <em>WithBoxUnlocked</em> que toma un valor de función como argumento, desbloquea la casilla, ejecuta la función y, a continuación, asegura que la casilla se bloquea de nuevo antes de volver, independientemente de si la función de argumento ha devuelto normalmente o ha lanzado una excepción.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_MZrCXjAAIp" href="#c_MZrCXjAAIp"></a><span class="cm-keyword">function</span> <span class="cm-variable">withBoxUnlocked</span>(<span class="cm-def">body</span>) {
  <span class="cm-comment">// Your code here.</span>
}

<span class="cm-variable">withBoxUnlocked</span>(<span class="cm-keyword">function</span>() {
  <span class="cm-variable">box</span>.<span class="cm-property">content</span>.<span class="cm-property">push</span>(<span class="cm-string">"gold piece"</span>);
});

<span class="cm-keyword">try</span> {
  <span class="cm-variable">withBoxUnlocked</span>(<span class="cm-keyword">function</span>() {
    <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">Error</span>(<span class="cm-string">"Pirates on the horizon! Abort!"</span>);
  });
} <span class="cm-keyword">catch</span> (<span class="cm-def">e</span>) {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Error raised:"</span>, <span class="cm-variable-2">e</span>);
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">box</span>.<span class="cm-property">locked</span>);
<span class="cm-comment">// → true</span></pre>
<p><a class=p_ident id="p_+nuBfnb51x" href="#p_+nuBfnb51x"></a>Para obtener puntos adicionales, asegúrese de que si llama a WithBoxUnlocked cuando la caja ya está desbloqueada, la caja permanezca desbloqueada.</p>
<div class=solution><div class=solution-text>
<p><a class=p_ident id="p_m+mGeREfa0" href="#p_m+mGeREfa0"></a>Este ejercicio requiere un bloque <em>finally</em>, como usted probablemente adivinó. Su función primero debe desbloquear la caja y luego llamar a la función de argumento desde dentro de un <em>try</em>. El bloque <em>finally</em> después debe bloquear la caja de nuevo.</p>
<p><a class=p_ident id="p_PEZeqdEufK" href="#p_PEZeqdEufK"></a>Para cerciorarse de que no bloqueamos la caja cuando todavía no estaba bloqueada, revisar su bloqueo al inicio de la función y desbloquearla y bloquearla sólo cuando empezó bloqueada.</p>
</div></div>
<nav>
  <a href="07_elife.html" title="capítulo previo">◀</a>
  <a href="index.html" title="cover">◆</a>
  <a href="09_regexp.html" title="capítulo siguiente">▶</a>
</nav>
</article>
